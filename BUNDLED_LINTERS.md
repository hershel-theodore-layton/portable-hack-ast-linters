|                                                                                                                                                     Linter | Categories                                       | Heritage                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Rationale                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|                                                      [async_function_and_method_linter](./src/linters/hhast_adapted/async_function_and_method_linter.hack) | Consistency, Correctness                         | [AsyncFunctionAndMethodLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/AsyncFunctionAndMethodLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | It is important to await every `Awaitable<_>`. When making a blocking method async, you need to be sure you have updated all callers. By changing the name (by adding the async suffix), you get type errors for all the references. The following code is instantly recognizable as wrong `$x?->someMethodAsync()`, but the typechecker will not emit an error for it. _A `?Awaitable<_>` doesn't trigger the "you must await this check".\_                                                                                                        |
|                      [camel_cased_methods_underscored_functions_linter](./src/linters/hhast_adapted/camel_cased_methods_underscored_functions_linter.hack) | Consistency                                      | [CamelCasedMethodsUnderscoredFunctionsLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/CamelCasedMethodsUnderscoredFunctionsLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Hack has different casing styles for different entities. These were inherited from the ancestor language Hack was based on. Many programmers are used to using `PascalCase` for classnames, `camelCase` for methods, but not to `snake_case` functions. By encoding these naming rules in a linter, free functions will "do as the HSL does", which is written in the idiomatic style for Hack.                                                                                                                                                      |
|       [concat_merge_or_union_expression_can_be_simplified_linter](./src/linters/pha_native/concat_merge_or_union_expression_can_be_simplified_linter.hack) | Consistency, Redundancy                          | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | `Vec\concat(...)` and `vec(...)` do the same thing when only given a single argument. This is strictly redundant. The expression `Vec\concat($x)` can be simplified to `vec($x)` if `$x` is not already a vec, to _just_ `$x` if it is.                                                                                                                                                                                                                                                                                                              |
|                                                 [context_list_must_be_explicit_linter](./src/linters/pha_native/context_list_must_be_explicit_linter.hack) | Consistency                                      | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Sources published in the `HTL\` family of Software are context-aware. This linter ensures that a context list is specified in all places where this is syntactically valid. This prevents situations in which the context list is accidentally not specified and consumers of the library are unable to use code from a pure context. This linter is very pedantic, since it requires `[defaults]` to be specified in regular business logic. Think carefully if this is something you want to require in your projects before enabling this linter. |
|                 [context_list_must_be_explicit_on_io_functions_linter](./src/linters/pha_native/context_list_must_be_explicit_on_io_functions_linter.hack) | Consistency                                      | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | A version of the linter above that only requires context lists on functions that contain an `await` expression. Those functions perform I/O, so `[defaults]` is ~~almost~~ always the correct choice for those functions. This linter (and its included autofix) can help you bootstrap the adoption of contexts in a codebase that previously didn't have them.                                                                                                                                                                                     |
|                                       [count_expression_can_be_simplified_linter](./src/linters/pha_native/count_expression_can_be_simplified_linter.hack) | Consistency, Correctness, Redundancy             | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Using `C\count(...)` and comparing to `0` or `1` when `C\is_empty(...)` expresses what you are doing directly, is causing mental overhead for no reason. This linter also flags blatent incorrect expressions, such as `C\count(...) < 0` (counts can not be negative), `C\count(...) >= 0` is always true.                                                                                                                                                                                                                                          |
|                                                                [dont_await_in_a_loop_linter](./src/linters/hhast_adapted/dont_await_in_a_loop_linter.hack) | Performance                                      | [DontAwaitInALoopLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/DontAwaitInALoopLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | _Don't await in a loop_ is the oldest piece of advice routinely given to Hack programmers. It originated with the authors of the `async` features in the runtime, see [the hhvm user documentation](https://docs.hhvm.com/hack/asynchronous-operations/guidelines#do-not-use-async-in-loops). In short, programs that await in loops state: "You can't process ` n + 1` before `n` has been processed." If this isn't true, you have created a false dependency.                                                                                     |
|                                            [dont_create_forwarding_lambdas_linter](./src/linters/hhast_adapted/dont_create_forwarding_lambdas_linter.hack) | Consistency                                      | [DontCreateForwardingLambdasLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/DontCreateForwardingLambdasLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Before the introduction of function references to the Hack language, the language included a magic function, `fun(...)`. It was very verbose when using namespaces. `Vec\map($strings, fun('HH\Lib\Str\trim'))` did the same thing as `Vec\map($strings, Str\trim<>)` does today. Hack programmers would create an inline lambda to avoid using the `fun(...)` function like so `Vec\map($strings, $s ==> Str\trim($s))`. Old habits die hard, so a linter was in order.                                                                             |
|                                                 [dont_discard_new_expressions_linter](/src/linters/hhast_adapted/dont_discard_new_expressions_linter.hack) | Correctness                                      | [DontDiscardNewExpressionsLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/DontDiscardNewExpressionsLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | This linter was written to combat the following bug pattern: `if (something bad) { new Exception('bad'); }` Do you spot it? We are missing the `throw` keyword. This `if(...)` statement was intended as a guard clause, but it doesn't guard anything. The easiest way to prevent this bug is to disallow ignored `new` expressions. This proved to be a useful rule, regardless of the type of the expression, so the behavior applies to any `new` expression.                                                                                    |
|                                                                    [dont_use_asio_join_linter](./src/linters/hhast_adapted/dont_use_asio_join_linter.hack) | Performance                                      | [DontUseAsioJoinLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/DontUseAsioJoinLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | `HH\Asio\join(...)` blocks until an `Awaitable<T>` has resolved and returns the `T` synchronously. This is terrible for performance, since no other `Awaitables` (except for those blocking the current one) are allowed to run. Just use `await`. If you are in a not in an async context, make it async. If you end up in a `__construct()` method, you must create an async factory method and hand the `T` to the constructor, instead of doing async work in the constructor.                                                                   |
|                                                      [final_or_abstract_classes_linter](./src/linters/hhast_adapted/final_or_abstract_classes_linter.hack) | Unknown                                          | [FinalOrAbstractClassLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/FinalOrAbstractClassLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | _The rationale for this linter has been lost to time. The original [Github issue](https://github.com/hhvm/hhast/issues/87) notes: "There are exceptions, but this is a good general rule."._ Final classes are slightly easier to reason about, since you can assume that every class that is not final is extended somewhere.                                                                                                                                                                                                                       |
|                             [getter_method_could_have_a_context_list_linter](./src/linters/pha_native/getter_method_could_have_a_context_list_linter.hack) | Consistency                                      | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Getter methods are numerous, easy to detect in a linter, and can always be made pure. Introducing contexts in a existing application is a high friction activity. An application with impure getters is hostile to context lists. The developer will constantly have to `Go to definition`, add `[]`, go back to the callsite, when writing pure code. This linter will prevent this roundtrip in the trivial cases.                                                                                                                                 |
|                                  [group_use_statement_alphabetization_linter](./src/linters/hhast_adapted/group_use_statement_alphabetization_linter.hack) | Consistency                                      | [GroupUseStatementAlphabetizationLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/GroupUseStatementAlphabetizationLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | The order of use statements does not matter. Alphabetical order is easy to explain and to enforce.                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                                                [group_use_statements_linter](./src/linters/hhast_adapted/group_use_statements_linter.hack) | Consistency, Redundancy                          | [GroupUseStatementsLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/GroupUseStatementsLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Namespaces that have a common prefix and expose multiple subnamespaces f.e. `HH\Lib\` or `HTL\` are intended to be consumed like this `use namespace HH\Lib\{Str, Vec}`, not like `use namespace HH\Lib\Str; use namespace HH\Lib\Vec;`. Grouping use clauses removes redundancy and makes code look more like the hsl, which is idiomatic Hack.                                                                                                                                                                                                     |
|                     [generated_file_may_not_be_modified_manually_linter](./src/linters/pha_native/generated_file_may_not_be_modified_manually_linter.hack) | Maintainability                                  | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | It is very easy to absentmindedly make edits to generated source code. These edits are overwritten the next time the source generator runs. This linter checks the first 20 hex-digits of the sha1 hash of the contents of the file (with the exception of the embedded hash) and compares this hash the hash embedded in the `<<file: Pragmas(vec['PhaLinters', 'digest:20-hex-digits-of-sha1'])>>` attribute. [This example](./tests/pragma/how_to_add_digests_to_generated_files.hack) demonstrates you how to add digests to your codegen.       |
|           [lambda_parameter_list_parentheses_can_be_removed_linter](./src/linters/pha_native/lambda_parameter_list_parentheses_can_be_removed_linter.hack) | Consistency                                      | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | When a lambda has a single argument, you may drop the parentheses around this argument. This is often done in predicates f.e. `$x ==> $x > 5`. This linter enforces that this style is consistently used over the `($x) ==> $x > 5` style.                                                                                                                                                                                                                                                                                                           |
|                                                                            [license_header_linter](./src/linters/hhast_adapted/license_header_linter.hack) | Consistency, Copyright                           | [LicenseHeaderLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/LicenseHeaderLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Ensures every file starts with a copyright notice. This is useful when dedicating a work to the Hack community.                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                        [must_use_braces_for_control_flow_linter](./src/linters/hhast_adapted/must_use_braces_for_control_flow_linter.hack) | Consistency, Correctness                         | [MustUseBracesForControlFlowLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/MustUseBracesForControlFlowLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Prevent confusion where a programmer assumes an `if (...)` reaches to the next closing curly brace. Ill-formatted code that uses braceless control flow may indent an incorrect amount of statements. If you format your code on save with `hackfmt`, this less of a problem than it used to be. These days, it enforces style rules more than anything else.                                                                                                                                                                                        |
|                                                        [namespace_private_symbol_linter](./src/linters/hhast_adapted/namespace_private_symbol_linter.hack) | Maintainability                                  | [NamespacePrivateLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/NamespacePrivateLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | The Hack community has adopted the `_Private` (or incorrectly `__Private`) namespace convention to isolate implementation details from the public API. The adoption of modules may make this convention obsolete. Code in a `_Private` subnamespace is not subject to a backwards compatibility guarantee and may be removed without warning. This linter warns you when you use such an API from **a different** vendor. You may (ab)use your own `_Private` symbols anywhere.                                                                      |
|                                                [namespace_private_use_clause_linter](./src/linters/hhast_adapted/namespace_private_use_clause_linter.hack) | Maintainability                                  | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | This linter will warn you at the time you write the use clause, instead of when you use the symbol in your code. See the rationale above.                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                                                                      [no_elseif_linter](./src/linters/hhast_adapted/no_elseif_linter.hack) | Consistency, Forwards Compatibility              | [NoElseifLinter](https://github.com/hhvm/hhast/blob/c5c6208af1be5cd6ec39fc73d68558d4c9a4a62d/src/Linters/NoElseifLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | `elseif` use to be an alternative spelling for `else if`. This alternative spelling was removed with the release of [hhvm version 4.158](https://hhvm.com/blog/2022/04/20/hhvm-4.158.html). If you typecheck on this hhvm version (or any newer version), you may remove this linter from your configuration without ill-effect.                                                                                                                                                                                                                     |
|                                                                  [no_empty_statements_linter](./src/linters/hhast_adapted/no_empty_statements_linter.hack) | Correctness, Redundancy                          | [NoEmptyStatementsLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/NoEmptyStatementsLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | A statement that has no effect is almost always an indication of a bug. For example `$a . $b`, `$a + 42`, which should have been `$a .= $b` and `$a += 42` respectively. In very few cases, the operator is used for short circuiting. `a() && b()`, where `b()` is only executed when `a()` returns a truthy value. In these cases, you may prefer to use an `if (...)` statement or to assign the resulting value to `$_` to signal this unidiomatic use of `&&`.                                                                                  |
|                                        [no_final_method_in_final_classes_linter](./src/linters/hhast_adapted/no_final_method_in_final_classes_linter.hack) | Redundancy                                       | [NoFinalMethodInFinalClassLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/NoFinalMethodInFinalClassLinter)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | A `final` method in a `final` class can not be overridden regardless of its modifier, because there are no subclasses. This is strictly redundant. It also gives a wrong impression that the methods around it that don't have a `final` modifier may be overridden in a subclass. By removing the `final` modifier, you remove this possibility for confusion.                                                                                                                                                                                      |
|                                                                          [no_php_equality_linter](./src/linters/hhast_adapted/no_php_equality_linter.hack) | Correctness, Forward Compatibility, Teachability | [NoPHPEqualityLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/NoPHPEqualityLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | This linter became a misnomer with the release of [hhvm version 4.116](https://hhvm.com/blog/2021/06/28/hhvm-4.116.html). In hhvm version 4.115 and below `==` and `!=` used to perform [Type Juggling](https://www.php.net/manual/en/language.types.type-juggling.php) and approximate the loose equality rules of PHP 7. The rules of modern `==` and `!=` are difficult to grasp. Always use strict equals `===` and `!==`.                                                                                                                       |
|                                                          [no_string_interpolation_linter](./src/linters/hhast_adapted/no_string_interpolation_linter.hack) | Consistency, Teachability                        | [NoStringInterpolationLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/NoStringInterpolationLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | The rationale for this lint has changed since it was added in 2017. See the [Github Issue](https://github.com/hhvm/hhast/issues/11). These days it reduces the amount of strange syntax exceptions that you need to know.[^1] With `enable_strict_string_concat_interp` enabled, one could argue this linter could allow simple variable interpolation `"Sally has $number_of_apples apple(s)"`.                                                                                                                                                     |
|                                                       [pragma_could_not_be_parsed_linter](./src/linters/pha_native/pragma_could_not_be_parsed_linter.hack) | Correctness, Redundancy                          | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Pragma's that address `PhaLinters`, but are not recognized and are red herrings. Delete them without remorse!                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                                                                 [pragma_prefix_unknown_linter](./src/linters/pha_native/pragma_prefix_unknown_linter.hack) | Correctness, Redundancy                          | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Pragma's that aren't being parsed by any tool just puzzle developers. Delete them without remorse!                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                                                            [prefer_lambdas_linter](./src/linters/hhast_adapted/prefer_lambdas_linter.hack) | Consistency, Teachability                        | [PreferLambdasLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/PreferLambdasLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | The alternative to lambda expressions is anonynous function expressions. Lambda's superceed anonynous function expressions in every way. They are more terse and they implicitly capture variables from enclosing scopes. By removing anonymous function expressions from your code, you won't need to teach how `function ($a) use ($b) { return $a + $b; }` is equivalent to `$a ==> $a + $b;`                                                                                                                                                     |
|                                                                  [prefer_require_once_linter](./src/linters/hhast_adapted/prefer_require_once_linter.hack) | Consistency                                      | [PreferRequireOnceLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/PreferRequireOnceLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | The inclusion directives, `include`, `include_once`, `require`, and `require_once` used to each have their own use in earlier versions of hhvm. The varaints without the `_once` suffix don't make sense in modern Hack, since including a file multiple times will either be a noop or raise a fatal error. `include_once` may be useful when a file may or may not exist. This is exeedingly rare and can be emulated using `if (\HH\could_include($x)) { require_once $x; }`                                                                      |
|                                [prefer_single_quoted_string_literals_linter](./src/linters/hhast_adapted/prefer_single_quoted_string_literals_linter.hack) | Consistency                                      | [PreferSingleQuotedStringLiteralLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/PreferSingleQuotedStringLiteralLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | The main difference between single quoted and double quoted strings are the escape characters you can use. Single quoted strings only allow `\'` (the escaped single quote) and `\\` (the escaped backslash). By using single quoted strings where you can, double quoted strings become a signal that says: escape sequences ahead.                                                                                                                                                                                                                 |
| [shape_type_additional_field_intent_should_be_explicit_linter](./src/linters/pha_native/shape_type_additional_field_intent_should_be_explicit_linter.hack) | Correctness                                      | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | This linter enforces that shapes are either open, or that the intent to leave the shape closed is expressed explicitly. `shape('x' => int)` does not allow additional fields. It is often unclear if the developer meant to leave the shape closed or if this worked and they averted their attention elsewhere, without considering the option. By requiring a token at the position where the `...` could have gone, you are forced to express your intent.                                                                                        |
|                                                          [shout_case_enum_members_linter](./src/linters/hhast_adapted/shout_case_enum_members_linter.hack) | Consistency                                      | [ShoutCaseEnumMembersLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/ShoutCaseEnumMembersLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Enum members are SHOUT_CASE by convention in Hack. In other programming languages, PascalCase is the convention. To aid new Hack developers and polyglots, this convention was encoded in a linter.                                                                                                                                                                                                                                                                                                                                                  |
|         [solitary_escape_sequences_should_be_disambiguated_linter](./src/linters/pha_native/solitary_escape_sequences_should_be_disambiguated_linter.hack) | Consistency, Readability                         | _null_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Programmers familiar with other C-like languages, are likely to confuse `'\n'` for a character literal containing a newline. Escape sequences in single quoted string literals are ignored (except for `\\` and `\'`). So these "character literals" are actually strings of length two where the first character is a backslash. To avoid this ambiguity, this linter requires you to write `'\\n'` instead. This is the same to Hack, but visually distinct from a C-style character literal.                                                      |
|                                                                        [unreachable_code_linter](./src/linters/hhast_adapted/unreachable_code_linter.hack) | Correctness, Redundancy                          | [UnreachableCodeLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/UnreachableCodeLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Code past `break;`, `continue;`, `return;`, and `throw ...;` directives is unreachable. It can be safely removed. In most cases it isn't rendundant, but it was misplaced. The author expected this code to be needed, so there may have been en error in understanding.                                                                                                                                                                                                                                                                             |
|                                                                [unused_pipe_variable_linter](./src/linters/hhast_adapted/unused_pipe_variable_linter.hack) | Correctness                                      | [UnusedPipeVariableLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/UnusedPipeVariableLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | This used to be a language rule until the release of [hhvm version 4.28](https://hhvm.com/blog/2019/10/23/hhvm-4.28.html). Not using the `$$` on the RHS of a `\|>` expression is almost always a bug. This error often takes the following form `Vec\filter($things, lambda) \|> Vec\map($things, lambda);` The `$things` variable has the same type as `$$`, so the typechecker does not flag this as an error and the filtered result is not used.                                                                                                |
|                                                                      [unused_use_clause_linter](./src/linters/hhast_adapted/unused_use_clause_linter.hack) | Redundancy                                       | [UnusedUseClauseLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/UnusedUseClauseLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | This is dead code, but you need to scan the whole file to be sure it is. By linting against it, you know that every use clause that remains is used somewhere in this file.                                                                                                                                                                                                                                                                                                                                                                          |
|                                                                          [unused_variable_linter](./src/linters/hhast_adapted/unused_variable_linter.hack) | Correctness, Maintainability, Redundancy         | [UnusedLambdaParameterLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/UnusedLambdaParameterLinter.hack) <br> [UnusedParameterLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/UnusedParameterLinter.hack) <br> [UnusedVariableLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/UnusedVariableLinter.hack)                                                                                                                                                                                                                                                                                                                         | Initializing `$flag = false;` outside a loop and conditionally setting `$falg = false;` inside the loop is the most common mistake caught by this linter. `$flag` will always be false. This linter also fires for unused parameters, which hurt maintainability. Naming unused parameters `$_` which are forced by the Liskov Substitution Principle ensures callers you won't use it. They may pass any type correct value. In other cases, the local variable is merely redundant.                                                                |
|                                                              [use_statement_with_as_linter](./src/linters/hhast_adapted/use_statement_with_as_linter.hack) | Consistency, Maintainability                     | [UseStatementWithAsLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/UseStatementWithAsLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Namespace, function, const, and type aliasses make code it more difficult to grep for the usage of these symbols. You rarely need to use aliasses to prevent naming collisions because of Hack's unambiguous naming rules. _Hack requires unambiguous uses. `use const Some\Package\SOME_CONST;` introduces the name `SOME_CONST` and `use namespace Some\Package;` introduces `Package` as a **local prefix**, instead of importing everything from `Some\Package` into file scope._                                                                |
|                                [use_statement_with_leading_backslash_linter](./src/linters/hhast_adapted/use_statement_with_leading_backslash_linter.hack) | Redundancy                                       | [UseStatementWithLeadingBackslashLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/UseStatementWithLeadingBackslashLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Use statements in Hack are not relative to the current namespace. They are rooted in the root namespace. The leading backslash does nothing. `use namespace A\B;` and `use namespace \A\B;` both introduce `B` as a local alias for `\A\B`.                                                                                                                                                                                                                                                                                                          |
|                                                    [use_statement_without_kind_linter](./src/linters/hhast_adapted/use_statement_without_kind_linter.hack) | Consistency, Maintainability, Teachability       | [UseStatementWithoutKindLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/UseStatementWithoutKindLinter.hack)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Way back when, use clauses didn't have a kind. `use A\B;` was _the_ way to introduce `B` as a local alias for the namespace `A\B` **and**, if it exists, the type `A\B`. This is still part of the language for backwards compability. Types rarely if ever share a name with a namespace, making this use clause needlessly non specific. I wouldn't have learned the rules for which clause wins when if I didn't write tooling. It is better to not have to teach it as well.                                                                     |
|                                             [variable_name_must_be_lowercase_linter](./src/linters/pha_native/variable_name_must_be_lowercase_linter.hack) | _null_                                           | Consistency                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | The Hack community uses `$snake_case` for local variables. Variable names are only `$camelCase` when they are used as constructor promoted properties. Camel case is popular in other communities. This linter serves as a gentle reminder to be consistent with other Hack code out there.                                                                                                                                                                                                                                                          |
|                                                                                    [whitespace_linter](./src/linters/hhast_adapted/whitespace_linter.hack) | Consistency, Maintainability                     | [ConsistentLineEndingsLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/ConsistentLineEndingsLinter.hack) <br> [DontHaveTwoEmptyLinesInARowLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/DontHaveTwoEmptyLinesInARowLinter.hack) <br> [NewlineAtEndOfFileLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/NewlineAtEndOfFileLinter.hack) <br> [NoNewlineAtStartOfControlFlowBlockLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/NoNewlineAtStartOfControlFlowBlockLinter.hack) <br> [NoWhitespaceAtEndOfLineLinter](https://github.com/hhvm/hhast/blob/v4.168.3/src/Linters/NoWhitespaceAtEndOfLineLinter.hack) | Being consistent with whitespace simplifies (git) diffs. This makes `git blame` more useful over time.                                                                                                                                                                                                                                                                                                                                                                                                                                               |

[^1]: `const string C = 'c'; $d = dict['C' => 'uppercase', 'c' => 'lowercase']; $d[C] (lowercase) vs "$d[C]" (uppercase); $d['C'] (uppercase) vs "$d['C']" (syntax error);`
