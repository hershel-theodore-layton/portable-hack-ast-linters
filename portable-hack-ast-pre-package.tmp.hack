///// src/Kind.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
newtype Kind as string = string;
newtype SyntaxKind as Kind = Kind;
newtype TokenKind as Kind = Kind;
newtype TriviumKind as Kind = Kind;

function syntax_kind_from_kind(Kind $kind)[]: SyntaxKind {
  return $kind;
}

function syntax_kind_from_string(string $str)[]: SyntaxKind {
  return $str;
}

function token_kind_from_kind(Kind $kind)[]: TokenKind {
  return $kind;
}

function token_kind_from_string(string $str)[]: TokenKind {
  return $str;
}

function trivium_kind_from_kind(Kind $kind)[]: TriviumKind {
  return $kind;
}

function trivium_kind_from_string(string $str)[]: TriviumKind {
  return $str;
}

// Missing the codegen...
const SyntaxKind KIND_NAME_EXPRESSION = 'name_expression';
const SyntaxKind KIND_NODE_LIST = 'node_list';
const SyntaxKind KIND_MISSING = 'missing';

const TriviumKind KIND_DELIMITED_COMMENT = 'delimited_comment';
const TriviumKind KIND_END_OF_LINE = 'end_of_line';
const TriviumKind KIND_FALL_THROUGH_COMMENT = 'fall_through';
const TriviumKind KIND_FIX_ME = 'fix_me';
const TriviumKind KIND_IGNORE_ERROR = 'ignore_error';
const TriviumKind KIND_SINGLE_LINE_COMMENT = 'single_line_comment';
const TriviumKind KIND_TOKEN_TEXT = 'token_text';
const TriviumKind KIND_WHITESPACE = 'whitespace';

// #region GENERATED CODE DO NOT EDIT BY HAND!
// This code was generated by bin/codegen_kind_constants.hack "4.94-172".

const SyntaxKind KIND_ALIAS_DECLARATION = 'alias_declaration';
const SyntaxKind KIND_ANONYMOUS_CLASS = 'anonymous_class';
const SyntaxKind KIND_ANONYMOUS_FUNCTION = 'anonymous_function';
const SyntaxKind KIND_ANONYMOUS_FUNCTION_USE_CLAUSE = 'anonymous_function_use_clause';
const SyntaxKind KIND_AS_EXPRESSION = 'as_expression';
const SyntaxKind KIND_ATTRIBUTE_SYNTAX = 'attribute';
const SyntaxKind KIND_ATTRIBUTE_SPECIFICATION = 'attribute_specification';
const SyntaxKind KIND_ATTRIBUTIZED_SPECIFIER = 'attributized_specifier';
const SyntaxKind KIND_AWAITABLE_CREATION_EXPRESSION = 'awaitable_creation_expression';
const SyntaxKind KIND_BINARY_EXPRESSION = 'binary_expression';
const SyntaxKind KIND_BRACED_EXPRESSION = 'braced_expression';
const SyntaxKind KIND_BREAK_STATEMENT = 'break_statement';
const SyntaxKind KIND_CASE_LABEL = 'case_label';
const SyntaxKind KIND_CAST_EXPRESSION = 'cast_expression';
const SyntaxKind KIND_CATCH_CLAUSE = 'catch_clause';
const SyntaxKind KIND_CLASSISH_BODY = 'classish_body';
const SyntaxKind KIND_CLASSISH_DECLARATION = 'classish_declaration';
const SyntaxKind KIND_CLASSNAME_TYPE_SPECIFIER = 'classname_type_specifier';
const SyntaxKind KIND_CLOSURE_PARAMETER_TYPE_SPECIFIER = 'closure_parameter_type_specifier';
const SyntaxKind KIND_CLOSURE_TYPE_SPECIFIER = 'closure_type_specifier';
const SyntaxKind KIND_COLLECTION_LITERAL_EXPRESSION = 'collection_literal_expression';
const SyntaxKind KIND_COMPOUND_STATEMENT = 'compound_statement';
const SyntaxKind KIND_CONCURRENT_STATEMENT = 'concurrent_statement';
const SyntaxKind KIND_CONDITIONAL_EXPRESSION = 'conditional_expression';
const SyntaxKind KIND_CONSTANT_DECLARATOR = 'constant_declarator';
const SyntaxKind KIND_CONSTRUCTOR_CALL = 'constructor_call';
const SyntaxKind KIND_CONST_DECLARATION = 'const_declaration';
const SyntaxKind KIND_CONTEXTS = 'contexts';
const SyntaxKind KIND_CONTEXT_ALIAS_DECLARATION = 'context_alias_declaration';
const SyntaxKind KIND_CONTEXT_CONSTRAINT = 'context_constraint';
const SyntaxKind KIND_CONTEXT_CONST_DECLARATION = 'context_const_declaration';
const SyntaxKind KIND_CONTINUE_STATEMENT = 'continue_statement';
const SyntaxKind KIND_CTX_IN_REFINEMENT = 'ctx_in_refinement';
const SyntaxKind KIND_DARRAY_INTRINSIC_EXPRESSION = 'darray_intrinsic_expression';
const SyntaxKind KIND_DARRAY_TYPE_SPECIFIER = 'darray_type_specifier';
const SyntaxKind KIND_DECORATED_EXPRESSION = 'decorated_expression';
const SyntaxKind KIND_DEFAULT_LABEL = 'default_label';
const SyntaxKind KIND_DEFINE_EXPRESSION = 'define_expression';
const SyntaxKind KIND_DICTIONARY_INTRINSIC_EXPRESSION = 'dictionary_intrinsic_expression';
const SyntaxKind KIND_DICTIONARY_TYPE_SPECIFIER = 'dictionary_type_specifier';
const SyntaxKind KIND_DO_STATEMENT = 'do_statement';
const SyntaxKind KIND_ECHO_STATEMENT = 'echo_statement';
const SyntaxKind KIND_ELEMENT_INITIALIZER = 'element_initializer';
const SyntaxKind KIND_ELSEIF_CLAUSE = 'elseif_clause';
const SyntaxKind KIND_ELSE_CLAUSE = 'else_clause';
const SyntaxKind KIND_EMBEDDED_BRACED_EXPRESSION = 'embedded_braced_expression';
const SyntaxKind KIND_EMBEDDED_MEMBER_SELECTION_EXPRESSION = 'embedded_member_selection_expression';
const SyntaxKind KIND_EMBEDDED_SUBSCRIPT_EXPRESSION = 'embedded_subscript_expression';
const SyntaxKind KIND_END_OF_FILE = 'end_of_file';
const SyntaxKind KIND_ENUMERATOR = 'enumerator';
const SyntaxKind KIND_ENUM_ATOM_EXPRESSION = 'enum_atom_expression';
const SyntaxKind KIND_ENUM_CLASS_DECLARATION = 'enum_class_declaration';
const SyntaxKind KIND_ENUM_CLASS_ENUMERATOR = 'enum_class_enumerator';
const SyntaxKind KIND_ENUM_CLASS_LABEL_EXPRESSION = 'enum_class_label_expression';
const SyntaxKind KIND_ENUM_DECLARATION = 'enum_declaration';
const SyntaxKind KIND_ENUM_USE = 'enum_use';
const SyntaxKind KIND_ERROR_SYNTAX = 'error_syntax';
const SyntaxKind KIND_ETSPLICE_EXPRESSION = 'eTSplice_expression';
const SyntaxKind KIND_EVAL_EXPRESSION = 'eval_expression';
const SyntaxKind KIND_EXPRESSION_STATEMENT = 'expression_statement';
const SyntaxKind KIND_FIELD_INITIALIZER = 'field_initializer';
const SyntaxKind KIND_FIELD_SPECIFIER = 'field_specifier';
const SyntaxKind KIND_FILE_ATTRIBUTE_SPECIFICATION = 'file_attribute_specification';
const SyntaxKind KIND_FINALLY_CLAUSE = 'finally_clause';
const SyntaxKind KIND_FOREACH_STATEMENT = 'foreach_statement';
const SyntaxKind KIND_FOR_STATEMENT = 'for_statement';
const SyntaxKind KIND_FUNCTION_CALL_EXPRESSION = 'function_call_expression';
const SyntaxKind KIND_FUNCTION_CTX_TYPE_SPECIFIER = 'function_ctx_type_specifier';
const SyntaxKind KIND_FUNCTION_DECLARATION = 'function_declaration';
const SyntaxKind KIND_FUNCTION_DECLARATION_HEADER = 'function_declaration_header';
const SyntaxKind KIND_FUNCTION_POINTER_EXPRESSION = 'function_pointer_expression';
const SyntaxKind KIND_GENERIC_TYPE_SPECIFIER = 'generic_type_specifier';
const SyntaxKind KIND_IF_STATEMENT = 'if_statement';
const SyntaxKind KIND_INCLUSION_DIRECTIVE = 'inclusion_directive';
const SyntaxKind KIND_INCLUSION_EXPRESSION = 'inclusion_expression';
const SyntaxKind KIND_INTERSECTION_TYPE_SPECIFIER = 'intersection_type_specifier';
const SyntaxKind KIND_ISSET_EXPRESSION = 'isset_expression';
const SyntaxKind KIND_IS_EXPRESSION = 'is_expression';
const SyntaxKind KIND_KEYSET_INTRINSIC_EXPRESSION = 'keyset_intrinsic_expression';
const SyntaxKind KIND_KEYSET_TYPE_SPECIFIER = 'keyset_type_specifier';
const SyntaxKind KIND_LAMBDA_EXPRESSION = 'lambda_expression';
const SyntaxKind KIND_LAMBDA_SIGNATURE = 'lambda_signature';
const SyntaxKind KIND_LIKE_TYPE_SPECIFIER = 'like_type_specifier';
const SyntaxKind KIND_LIST_EXPRESSION = 'list_expression';
const SyntaxKind KIND_LIST_ITEM = 'list_item';
const SyntaxKind KIND_LITERAL = 'literal';
const SyntaxKind KIND_MARKUP_SECTION = 'markup_section';
const SyntaxKind KIND_MARKUP_SUFFIX = 'markup_suffix';
const SyntaxKind KIND_MEMBER_SELECTION_EXPRESSION = 'member_selection_expression';
const SyntaxKind KIND_METHODISH_DECLARATION = 'methodish_declaration';
const SyntaxKind KIND_METHODISH_TRAIT_RESOLUTION = 'methodish_trait_resolution';
const SyntaxKind KIND_MODULE_DECLARATION = 'module_declaration';
const SyntaxKind KIND_MODULE_EXPORTS = 'module_exports';
const SyntaxKind KIND_MODULE_IMPORTS = 'module_imports';
const SyntaxKind KIND_MODULE_MEMBERSHIP_DECLARATION = 'module_membership_declaration';
const SyntaxKind KIND_MODULE_NAME = 'module_name';
const SyntaxKind KIND_NAMESPACE_BODY = 'namespace_body';
const SyntaxKind KIND_NAMESPACE_DECLARATION = 'namespace_declaration';
const SyntaxKind KIND_NAMESPACE_DECLARATION_HEADER = 'namespace_declaration_header';
const SyntaxKind KIND_NAMESPACE_EMPTY_BODY = 'namespace_empty_body';
const SyntaxKind KIND_NAMESPACE_GROUP_USE_DECLARATION = 'namespace_group_use_declaration';
const SyntaxKind KIND_NAMESPACE_USE_CLAUSE = 'namespace_use_clause';
const SyntaxKind KIND_NAMESPACE_USE_DECLARATION = 'namespace_use_declaration';
const SyntaxKind KIND_NULLABLE_AS_EXPRESSION = 'nullable_as_expression';
const SyntaxKind KIND_NULLABLE_TYPE_SPECIFIER = 'nullable_type_specifier';
const SyntaxKind KIND_OBJECT_CREATION_EXPRESSION = 'object_creation_expression';
const SyntaxKind KIND_OLD_ATTRIBUTE_SPECIFICATION = 'old_attribute_specification';
const SyntaxKind KIND_PACKAGE_DECLARATION = 'package_declaration';
const SyntaxKind KIND_PACKAGE_INCLUDES = 'package_includes';
const SyntaxKind KIND_PACKAGE_USES = 'package_uses';
const SyntaxKind KIND_PARAMETER_DECLARATION = 'parameter_declaration';
const SyntaxKind KIND_PARENTHESIZED_EXPRESSION = 'parenthesized_expression';
const SyntaxKind KIND_PIPE_VARIABLE = 'pipe_variable';
const SyntaxKind KIND_POSTFIX_UNARY_EXPRESSION = 'postfix_unary_expression';
const SyntaxKind KIND_PREFIXED_CODE_EXPRESSION = 'prefixed_code_expression';
const SyntaxKind KIND_PREFIXED_STRING = 'prefixed_string';
const SyntaxKind KIND_PREFIX_UNARY_EXPRESSION = 'prefix_unary_expression';
const SyntaxKind KIND_PROPERTY_DECLARATION = 'property_declaration';
const SyntaxKind KIND_PROPERTY_DECLARATOR = 'property_declarator';
const SyntaxKind KIND_QUALIFIED_NAME = 'qualified_name';
const SyntaxKind KIND_RECORD_CREATION_EXPRESSION = 'record_creation_expression';
const SyntaxKind KIND_RECORD_DECLARATION = 'record_declaration';
const SyntaxKind KIND_RECORD_FIELD = 'record_field';
const SyntaxKind KIND_REIFIED_TYPE_ARGUMENT = 'reified_type_argument';
const SyntaxKind KIND_REQUIRE_CLAUSE = 'require_clause';
const SyntaxKind KIND_RETURN_STATEMENT = 'return_statement';
const SyntaxKind KIND_SAFE_MEMBER_SELECTION_EXPRESSION = 'safe_member_selection_expression';
const SyntaxKind KIND_SCOPE_RESOLUTION_EXPRESSION = 'scope_resolution_expression';
const SyntaxKind KIND_SCRIPT = 'script';
const SyntaxKind KIND_SHAPE_EXPRESSION = 'shape_expression';
const SyntaxKind KIND_SHAPE_TYPE_SPECIFIER = 'shape_type_specifier';
const SyntaxKind KIND_SIMPLE_INITIALIZER = 'simple_initializer';
const SyntaxKind KIND_SIMPLE_TYPE_SPECIFIER = 'simple_type_specifier';
const SyntaxKind KIND_SOFT_TYPE_SPECIFIER = 'soft_type_specifier';
const SyntaxKind KIND_SUBSCRIPT_EXPRESSION = 'subscript_expression';
const SyntaxKind KIND_SWITCH_FALLTHROUGH = 'switch_fallthrough';
const SyntaxKind KIND_SWITCH_SECTION = 'switch_section';
const SyntaxKind KIND_SWITCH_STATEMENT = 'switch_statement';
const SyntaxKind KIND_THROW_STATEMENT = 'throw_statement';
const SyntaxKind KIND_TRAIT_USE = 'trait_use';
const SyntaxKind KIND_TRAIT_USE_ALIAS_ITEM = 'trait_use_alias_item';
const SyntaxKind KIND_TRAIT_USE_CONFLICT_RESOLUTION = 'trait_use_conflict_resolution';
const SyntaxKind KIND_TRAIT_USE_PRECEDENCE_ITEM = 'trait_use_precedence_item';
const SyntaxKind KIND_TRY_STATEMENT = 'try_statement';
const SyntaxKind KIND_TUPLE_EXPRESSION = 'tuple_expression';
const SyntaxKind KIND_TUPLE_TYPE_EXPLICIT_SPECIFIER = 'tuple_type_explicit_specifier';
const SyntaxKind KIND_TUPLE_TYPE_SPECIFIER = 'tuple_type_specifier';
const SyntaxKind KIND_TYPE_ARGUMENTS = 'type_arguments';
const SyntaxKind KIND_TYPE_CONSTANT = 'type_constant';
const SyntaxKind KIND_TYPE_CONSTRAINT = 'type_constraint';
const SyntaxKind KIND_TYPE_CONST_DECLARATION = 'type_const_declaration';
const SyntaxKind KIND_TYPE_IN_REFINEMENT = 'type_in_refinement';
const SyntaxKind KIND_TYPE_PARAMETER = 'type_parameter';
const SyntaxKind KIND_TYPE_PARAMETERS = 'type_parameters';
const SyntaxKind KIND_TYPE_REFINEMENT = 'type_refinement';
const SyntaxKind KIND_UNION_TYPE_SPECIFIER = 'union_type_specifier';
const SyntaxKind KIND_UNSET_STATEMENT = 'unset_statement';
const SyntaxKind KIND_UPCAST_EXPRESSION = 'upcast_expression';
const SyntaxKind KIND_USING_STATEMENT_BLOCK_SCOPED = 'using_statement_block_scoped';
const SyntaxKind KIND_USING_STATEMENT_FUNCTION_SCOPED = 'using_statement_function_scoped';
const SyntaxKind KIND_VARIABLE_SYNTAX = 'variable';
const SyntaxKind KIND_VARIADIC_PARAMETER = 'variadic_parameter';
const SyntaxKind KIND_VARRAY_INTRINSIC_EXPRESSION = 'varray_intrinsic_expression';
const SyntaxKind KIND_VARRAY_TYPE_SPECIFIER = 'varray_type_specifier';
const SyntaxKind KIND_VECTOR_INTRINSIC_EXPRESSION = 'vector_intrinsic_expression';
const SyntaxKind KIND_VECTOR_TYPE_SPECIFIER = 'vector_type_specifier';
const SyntaxKind KIND_WHERE_CLAUSE = 'where_clause';
const SyntaxKind KIND_WHERE_CONSTRAINT = 'where_constraint';
const SyntaxKind KIND_WHILE_STATEMENT = 'while_statement';
const SyntaxKind KIND_XHP_CATEGORY_DECLARATION = 'xhp_category_declaration';
const SyntaxKind KIND_XHP_CHILDREN_DECLARATION = 'xhp_children_declaration';
const SyntaxKind KIND_XHP_CHILDREN_PARENTHESIZED_LIST = 'xhp_children_parenthesized_list';
const SyntaxKind KIND_XHP_CLASS_ATTRIBUTE = 'xhp_class_attribute';
const SyntaxKind KIND_XHP_CLASS_ATTRIBUTE_DECLARATION = 'xhp_class_attribute_declaration';
const SyntaxKind KIND_XHP_CLOSE = 'xhp_close';
const SyntaxKind KIND_XHP_ENUM_TYPE = 'xhp_enum_type';
const SyntaxKind KIND_XHP_EXPRESSION = 'xhp_expression';
const SyntaxKind KIND_XHP_LATEINIT = 'XHP_lateinit';
const SyntaxKind KIND_XHP_OPEN = 'xhp_open';
const SyntaxKind KIND_XHP_REQUIRED = 'xhp_required';
const SyntaxKind KIND_XHP_SIMPLE_ATTRIBUTE = 'xhp_simple_attribute';
const SyntaxKind KIND_XHP_SIMPLE_CLASS_ATTRIBUTE = 'XHP_simple_class_attribute';
const SyntaxKind KIND_XHP_SPREAD_ATTRIBUTE = 'xhp_spread_attribute';
const SyntaxKind KIND_YIELD_BREAK_STATEMENT = 'yield_break_statement';
const SyntaxKind KIND_YIELD_EXPRESSION = 'yield_expression';

const TokenKind KIND_ABSTRACT = 'abstract';
const TokenKind KIND_AMPERSAND = '&';
const TokenKind KIND_AMPERSAND_AMPERSAND = '&&';
const TokenKind KIND_AMPERSAND_EQUAL = '&=';
const TokenKind KIND_ARRAYKEY = 'arraykey';
const TokenKind KIND_AS = 'as';
const TokenKind KIND_ASYNC = 'async';
const TokenKind KIND_AT = '@';
const TokenKind KIND_ATTRIBUTE_TOKEN = 'attribute';
const TokenKind KIND_AWAIT = 'await';
const TokenKind KIND_BACKSLASH = '\\';
const TokenKind KIND_BACKTICK = '`';
const TokenKind KIND_BAR = '|';
const TokenKind KIND_BAR_BAR = '||';
const TokenKind KIND_BAR_EQUAL = '|=';
const TokenKind KIND_BAR_GREATER_THAN = '|>';
const TokenKind KIND_BINARY = 'binary';
const TokenKind KIND_BINARY_LITERAL = 'binary_literal';
const TokenKind KIND_BOOL = 'bool';
const TokenKind KIND_BOOLEAN = 'boolean';
const TokenKind KIND_BOOLEAN_LITERAL = 'boolean_literal';
const TokenKind KIND_BREAK = 'break';
const TokenKind KIND_CARAT = '^';
const TokenKind KIND_CARAT_EQUAL = '^=';
const TokenKind KIND_CASE = 'case';
const TokenKind KIND_CATCH = 'catch';
const TokenKind KIND_CATEGORY = 'category';
const TokenKind KIND_CHILDREN = 'children';
const TokenKind KIND_CLASS = 'class';
const TokenKind KIND_CLASSNAME = 'classname';
const TokenKind KIND_CLONE = 'clone';
const TokenKind KIND_COLON = ':';
const TokenKind KIND_COLON_COLON = '::';
const TokenKind KIND_COMMA = ',';
const TokenKind KIND_CONCURRENT = 'concurrent';
const TokenKind KIND_CONST = 'const';
const TokenKind KIND_CONSTRUCT = '__construct';
const TokenKind KIND_CONTINUE = 'continue';
const TokenKind KIND_CTX = 'ctx';
const TokenKind KIND_DARRAY = 'darray';
const TokenKind KIND_DECIMAL_LITERAL = 'decimal_literal';
const TokenKind KIND_DEFAULT = 'default';
const TokenKind KIND_DEFINE = 'define';
const TokenKind KIND_DICT = 'dict';
const TokenKind KIND_DO = 'do';
const TokenKind KIND_DOLLAR = '$';
const TokenKind KIND_DOLLAR_DOLLAR = '$$';
const TokenKind KIND_DOT = '.';
const TokenKind KIND_DOT_DOT_DOT = '...';
const TokenKind KIND_DOT_EQUAL = '.=';
const TokenKind KIND_DOUBLE = 'double';
const TokenKind KIND_DOUBLE_QUOTED_STRING_LITERAL = 'double_quoted_string_literal';
const TokenKind KIND_DOUBLE_QUOTED_STRING_LITERAL_HEAD = 'double_quoted_string_literal_head';
const TokenKind KIND_DOUBLE_QUOTED_STRING_LITERAL_TAIL = 'double_quoted_string_literal_tail';
const TokenKind KIND_ECHO = 'echo';
const TokenKind KIND_ELSE = 'else';
const TokenKind KIND_ELSEIF = 'elseif';
const TokenKind KIND_EMPTY = 'empty';
const TokenKind KIND_ENDFOR = 'endfor';
const TokenKind KIND_ENDFOREACH = 'endforeach';
const TokenKind KIND_ENDIF = 'endif';
const TokenKind KIND_ENDSWITCH = 'endswitch';
const TokenKind KIND_ENDWHILE = 'endwhile';
const TokenKind KIND_ENUM = 'enum';
const TokenKind KIND_EQUAL = '=';
const TokenKind KIND_EQUAL_EQUAL = '==';
const TokenKind KIND_EQUAL_EQUAL_EQUAL = '===';
const TokenKind KIND_EQUAL_EQUAL_GREATER_THAN = '==>';
const TokenKind KIND_EQUAL_GREATER_THAN = '=>';
const TokenKind KIND_ERROR_TOKEN = 'error_token';
const TokenKind KIND_EVAL = 'eval';
const TokenKind KIND_EXCLAMATION = '!';
const TokenKind KIND_EXCLAMATION_EQUAL = '!=';
const TokenKind KIND_EXCLAMATION_EQUAL_EQUAL = '!==';
const TokenKind KIND_EXPORTS = 'exports';
const TokenKind KIND_EXTENDS = 'extends';
const TokenKind KIND_FALLTHROUGH = 'fallthrough';
const TokenKind KIND_FILE = 'file';
const TokenKind KIND_FINAL = 'final';
const TokenKind KIND_FINALLY = 'finally';
const TokenKind KIND_FLOAT = 'float';
const TokenKind KIND_FLOATING_LITERAL = 'floating_literal';
const TokenKind KIND_FOR = 'for';
const TokenKind KIND_FOREACH = 'foreach';
const TokenKind KIND_FROM = 'from';
const TokenKind KIND_FUNCTION = 'function';
const TokenKind KIND_GLOBAL = 'global';
const TokenKind KIND_GREATER_THAN = '>';
const TokenKind KIND_GREATER_THAN_EQUAL = '>=';
const TokenKind KIND_GREATER_THAN_GREATER_THAN = '>>';
const TokenKind KIND_GREATER_THAN_GREATER_THAN_EQUAL = '>>=';
const TokenKind KIND_HASH = '#';
const TokenKind KIND_HASHBANG = 'hashbang';
const TokenKind KIND_HEREDOC_STRING_LITERAL = 'heredoc_string_literal';
const TokenKind KIND_HEREDOC_STRING_LITERAL_HEAD = 'heredoc_string_literal_head';
const TokenKind KIND_HEREDOC_STRING_LITERAL_TAIL = 'heredoc_string_literal_tail';
const TokenKind KIND_HEXADECIMAL_LITERAL = 'hexadecimal_literal';
const TokenKind KIND_IF = 'if';
const TokenKind KIND_IMPLEMENTS = 'implements';
const TokenKind KIND_IMPORTS = 'imports';
const TokenKind KIND_INCLUDE = 'include';
const TokenKind KIND_INCLUDE_ONCE = 'include_once';
const TokenKind KIND_INOUT = 'inout';
const TokenKind KIND_INSTANCEOF = 'instanceof';
const TokenKind KIND_INSTEADOF = 'insteadof';
const TokenKind KIND_INT = 'int';
const TokenKind KIND_INTEGER = 'integer';
const TokenKind KIND_INTERFACE = 'interface';
const TokenKind KIND_INTERNAL = 'internal';
const TokenKind KIND_IS = 'is';
const TokenKind KIND_ISSET = 'isset';
const TokenKind KIND_KEYSET = 'keyset';
const TokenKind KIND_LATEINIT = 'lateinit';
const TokenKind KIND_LEFT_BRACE = '{';
const TokenKind KIND_LEFT_BRACKET = '[';
const TokenKind KIND_LEFT_PAREN = '(';
const TokenKind KIND_LESS_THAN = '<';
const TokenKind KIND_LESS_THAN_EQUAL = '<=';
const TokenKind KIND_LESS_THAN_EQUAL_GREATER_THAN = '<=>';
const TokenKind KIND_LESS_THAN_LESS_THAN = '<<';
const TokenKind KIND_LESS_THAN_LESS_THAN_EQUAL = '<<=';
const TokenKind KIND_LESS_THAN_QUESTION = '<?';
const TokenKind KIND_LESS_THAN_SLASH = '</';
const TokenKind KIND_LIST = 'list';
const TokenKind KIND_MINUS = '-';
const TokenKind KIND_MINUS_EQUAL = '-=';
const TokenKind KIND_MINUS_GREATER_THAN = '->';
const TokenKind KIND_MINUS_MINUS = '--';
const TokenKind KIND_MIXED = 'mixed';
const TokenKind KIND_MODULE = 'module';
const TokenKind KIND_NAME = 'name';
const TokenKind KIND_NAMESPACE = 'namespace';
const TokenKind KIND_NEW = 'new';
const TokenKind KIND_NEWCTX = 'newctx';
const TokenKind KIND_NEWTYPE = 'newtype';
const TokenKind KIND_NORETURN = 'noreturn';
const TokenKind KIND_NOWDOC_STRING_LITERAL = 'nowdoc_string_literal';
const TokenKind KIND_NULL_LITERAL = 'null';
const TokenKind KIND_NUM = 'num';
const TokenKind KIND_OBJECT = 'object';
const TokenKind KIND_OCTAL_LITERAL = 'octal_literal';
const TokenKind KIND_PACKAGE = 'package';
const TokenKind KIND_PARENT = 'parent';
const TokenKind KIND_PERCENT = '%';
const TokenKind KIND_PERCENT_EQUAL = '%=';
const TokenKind KIND_PLUS = '+';
const TokenKind KIND_PLUS_EQUAL = '+=';
const TokenKind KIND_PLUS_PLUS = '++';
const TokenKind KIND_PRINT = 'print';
const TokenKind KIND_PRIVATE = 'private';
const TokenKind KIND_PROTECTED = 'protected';
const TokenKind KIND_PUBLIC = 'public';
const TokenKind KIND_QUESTION = '?';
const TokenKind KIND_QUESTION_AS = '?as';
const TokenKind KIND_QUESTION_COLON = '?:';
const TokenKind KIND_QUESTION_MINUS_GREATER_THAN = '?->';
const TokenKind KIND_QUESTION_QUESTION = '??';
const TokenKind KIND_QUESTION_QUESTION_EQUAL = '??=';
const TokenKind KIND_READONLY = 'readonly';
const TokenKind KIND_REAL = 'real';
const TokenKind KIND_RECORD = 'recordname';
const TokenKind KIND_RECORD_DEC = 'record';
const TokenKind KIND_REIFY = 'reify';
const TokenKind KIND_REQUIRE = 'require';
const TokenKind KIND_REQUIRED = 'required';
const TokenKind KIND_REQUIRE_ONCE = 'require_once';
const TokenKind KIND_RESOURCE = 'resource';
const TokenKind KIND_RETURN = 'return';
const TokenKind KIND_RIGHT_BRACE = '}';
const TokenKind KIND_RIGHT_BRACKET = ']';
const TokenKind KIND_RIGHT_PAREN = ')';
const TokenKind KIND_SELF = 'self';
const TokenKind KIND_SEMICOLON = ';';
const TokenKind KIND_SHAPE = 'shape';
const TokenKind KIND_SINGLE_QUOTED_STRING_LITERAL = 'single_quoted_string_literal';
const TokenKind KIND_SLASH = '/';
const TokenKind KIND_SLASH_EQUAL = '/=';
const TokenKind KIND_SLASH_GREATER_THAN = '/>';
const TokenKind KIND_STAR = '*';
const TokenKind KIND_STAR_EQUAL = '*=';
const TokenKind KIND_STAR_STAR = '**';
const TokenKind KIND_STAR_STAR_EQUAL = '**=';
const TokenKind KIND_STATIC = 'static';
const TokenKind KIND_STRING = 'string';
const TokenKind KIND_STRING_LITERAL_BODY = 'string_literal_body';
const TokenKind KIND_SUPER = 'super';
const TokenKind KIND_SWITCH = 'switch';
const TokenKind KIND_THIS = 'this';
const TokenKind KIND_THROW = 'throw';
const TokenKind KIND_TILDE = '~';
const TokenKind KIND_TRAIT = 'trait';
const TokenKind KIND_TRY = 'try';
const TokenKind KIND_TUPLE = 'tuple';
const TokenKind KIND_TYPE = 'type';
const TokenKind KIND_UNSET = 'unset';
const TokenKind KIND_UPCAST = 'upcast';
const TokenKind KIND_USE = 'use';
const TokenKind KIND_USING = 'using';
const TokenKind KIND_VAR = 'var';
const TokenKind KIND_VARIABLE_TOKEN = 'variable';
const TokenKind KIND_VARRAY = 'varray';
const TokenKind KIND_VEC = 'vec';
const TokenKind KIND_VOID = 'void';
const TokenKind KIND_WHERE = 'where';
const TokenKind KIND_WHILE = 'while';
const TokenKind KIND_WITH = 'with';
const TokenKind KIND_XHP = 'xhp';
const TokenKind KIND_XHP_BODY = 'XHP_body';
const TokenKind KIND_XHP_CATEGORY_NAME = 'XHP_category_name';
const TokenKind KIND_XHP_CLASS_NAME = 'XHP_class_name';
const TokenKind KIND_XHP_COMMENT = 'XHP_comment';
const TokenKind KIND_XHP_ELEMENT_NAME = 'XHP_element_name';
const TokenKind KIND_XHP_STRING_LITERAL = 'XHP_string_literal';
const TokenKind KIND_YIELD = 'yield';
// #endregion
}
///// src/LineAndColumnNumbers.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
final class LineAndColumnNumbers {
  public function __construct(
    private int $startLine,
    private int $startColumn,
    private int $endLine,
    private int $endColumn,
  )[] {}

  public function getStartLine()[]: int {
    return $this->startLine;
  }

  public function getStartLineOneBased()[]: int {
    return $this->startLine + 1;
  }

  public function getStartColumn()[]: int {
    return $this->startColumn;
  }

  public function getStartColumnOneBased()[]: int {
    return $this->startColumn + 1;
  }

  public function getEndLine()[]: int {
    return $this->endLine;
  }

  public function getEndLineOneBased()[]: int {
    return $this->endLine + 1;
  }

  public function getEndColumn()[]: int {
    return $this->endColumn;
  }

  public function getEndColumnOneBased()[]: int {
    return $this->endColumn + 1;
  }

  public function getStart()[]: (int, int) {
    return tuple($this->startLine, $this->startColumn);
  }

  public function getStartOneBased()[]: (int, int) {
    return
      tuple($this->getStartLineOneBased(), $this->getStartColumnOneBased());
  }

  public function getEnd()[]: (int, int) {
    return tuple($this->endLine, $this->endColumn);
  }

  public function getEndOneBased()[]: (int, int) {
    return tuple($this->getEndLineOneBased(), $this->getEndColumnOneBased());
  }
}
}
///// src/Member.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
newtype Member = (SyntaxKind, string);

function member_from_tuple((SyntaxKind, string) $tuple)[]: Member {
  return $tuple;
}

function member_to_tuple(Member $member)[]: (SyntaxKind, string) {
  return $member;
}

function member_get_name(Member $member)[]: string {
  return $member[1];
}

function member_get_syntax_kind(Member $member)[]: SyntaxKind {
  return $member[0];
}

// #region GENERATED CODE DO NOT EDIT BY HAND!
// This code was generated by bin/codegen_kind_constants.hack "4.94-172".

const Member MEMBER_ALIAS_ATTRIBUTE_SPEC = tuple(KIND_ALIAS_DECLARATION, 'alias_attribute_spec');
const Member MEMBER_ALIAS_CONSTRAINT = tuple(KIND_ALIAS_DECLARATION, 'alias_constraint');
const Member MEMBER_ALIAS_EQUAL = tuple(KIND_ALIAS_DECLARATION, 'alias_equal');
const Member MEMBER_ALIAS_GENERIC_PARAMETER = tuple(KIND_ALIAS_DECLARATION, 'alias_generic_parameter');
const Member MEMBER_ALIAS_KEYWORD = tuple(KIND_ALIAS_DECLARATION, 'alias_keyword');
const Member MEMBER_ALIAS_MODIFIERS = tuple(KIND_ALIAS_DECLARATION, 'alias_modifiers');
const Member MEMBER_ALIAS_MODULE_KW_OPT = tuple(KIND_ALIAS_DECLARATION, 'alias_module_kw_opt');
const Member MEMBER_ALIAS_NAME = tuple(KIND_ALIAS_DECLARATION, 'alias_name');
const Member MEMBER_ALIAS_SEMICOLON = tuple(KIND_ALIAS_DECLARATION, 'alias_semicolon');
const Member MEMBER_ALIAS_TYPE = tuple(KIND_ALIAS_DECLARATION, 'alias_type');
const Member MEMBER_ANONYMOUS_ASYNC_KEYWORD = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_async_keyword');
const Member MEMBER_ANONYMOUS_ATTRIBUTE_SPEC = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_attribute_spec');
const Member MEMBER_ANONYMOUS_BODY = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_body');
const Member MEMBER_ANONYMOUS_CLASS_ARGUMENT_LIST = tuple(KIND_ANONYMOUS_CLASS, 'anonymous_class_argument_list');
const Member MEMBER_ANONYMOUS_CLASS_BODY = tuple(KIND_ANONYMOUS_CLASS, 'anonymous_class_body');
const Member MEMBER_ANONYMOUS_CLASS_CLASS_KEYWORD = tuple(KIND_ANONYMOUS_CLASS, 'anonymous_class_class_keyword');
const Member MEMBER_ANONYMOUS_CLASS_EXTENDS_KEYWORD = tuple(KIND_ANONYMOUS_CLASS, 'anonymous_class_extends_keyword');
const Member MEMBER_ANONYMOUS_CLASS_EXTENDS_LIST = tuple(KIND_ANONYMOUS_CLASS, 'anonymous_class_extends_list');
const Member MEMBER_ANONYMOUS_CLASS_IMPLEMENTS_KEYWORD = tuple(KIND_ANONYMOUS_CLASS, 'anonymous_class_implements_keyword');
const Member MEMBER_ANONYMOUS_CLASS_IMPLEMENTS_LIST = tuple(KIND_ANONYMOUS_CLASS, 'anonymous_class_implements_list');
const Member MEMBER_ANONYMOUS_CLASS_LEFT_PAREN = tuple(KIND_ANONYMOUS_CLASS, 'anonymous_class_left_paren');
const Member MEMBER_ANONYMOUS_CLASS_RIGHT_PAREN = tuple(KIND_ANONYMOUS_CLASS, 'anonymous_class_right_paren');
const Member MEMBER_ANONYMOUS_COLON = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_colon');
const Member MEMBER_ANONYMOUS_CTX_LIST = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_ctx_list');
const Member MEMBER_ANONYMOUS_FUNCTION_KEYWORD = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_function_keyword');
const Member MEMBER_ANONYMOUS_LEFT_PAREN = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_left_paren');
const Member MEMBER_ANONYMOUS_PARAMETERS = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_parameters');
const Member MEMBER_ANONYMOUS_READONLY_RETURN = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_readonly_return');
const Member MEMBER_ANONYMOUS_RIGHT_PAREN = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_right_paren');
const Member MEMBER_ANONYMOUS_STATIC_KEYWORD = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_static_keyword');
const Member MEMBER_ANONYMOUS_TYPE = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_type');
const Member MEMBER_ANONYMOUS_USE = tuple(KIND_ANONYMOUS_FUNCTION, 'anonymous_use');
const Member MEMBER_ANONYMOUS_USE_KEYWORD = tuple(KIND_ANONYMOUS_FUNCTION_USE_CLAUSE, 'anonymous_use_keyword');
const Member MEMBER_ANONYMOUS_USE_LEFT_PAREN = tuple(KIND_ANONYMOUS_FUNCTION_USE_CLAUSE, 'anonymous_use_left_paren');
const Member MEMBER_ANONYMOUS_USE_RIGHT_PAREN = tuple(KIND_ANONYMOUS_FUNCTION_USE_CLAUSE, 'anonymous_use_right_paren');
const Member MEMBER_ANONYMOUS_USE_VARIABLES = tuple(KIND_ANONYMOUS_FUNCTION_USE_CLAUSE, 'anonymous_use_variables');
const Member MEMBER_AS_LEFT_OPERAND = tuple(KIND_AS_EXPRESSION, 'as_left_operand');
const Member MEMBER_AS_OPERATOR = tuple(KIND_AS_EXPRESSION, 'as_operator');
const Member MEMBER_AS_RIGHT_OPERAND = tuple(KIND_AS_EXPRESSION, 'as_right_operand');
const Member MEMBER_ATTRIBUTE_AT = tuple(KIND_ATTRIBUTE_SYNTAX, 'attribute_at');
const Member MEMBER_ATTRIBUTE_ATTRIBUTE_NAME = tuple(KIND_ATTRIBUTE_SYNTAX, 'attribute_attribute_name');
const Member MEMBER_ATTRIBUTE_SPECIFICATION_ATTRIBUTES = tuple(KIND_ATTRIBUTE_SPECIFICATION, 'attribute_specification_attributes');
const Member MEMBER_ATTRIBUTIZED_SPECIFIER_ATTRIBUTE_SPEC = tuple(KIND_ATTRIBUTIZED_SPECIFIER, 'attributized_specifier_attribute_spec');
const Member MEMBER_ATTRIBUTIZED_SPECIFIER_TYPE = tuple(KIND_ATTRIBUTIZED_SPECIFIER, 'attributized_specifier_type');
const Member MEMBER_AWAITABLE_ASYNC = tuple(KIND_AWAITABLE_CREATION_EXPRESSION, 'awaitable_async');
const Member MEMBER_AWAITABLE_ATTRIBUTE_SPEC = tuple(KIND_AWAITABLE_CREATION_EXPRESSION, 'awaitable_attribute_spec');
const Member MEMBER_AWAITABLE_COMPOUND_STATEMENT = tuple(KIND_AWAITABLE_CREATION_EXPRESSION, 'awaitable_compound_statement');
const Member MEMBER_BINARY_LEFT_OPERAND = tuple(KIND_BINARY_EXPRESSION, 'binary_left_operand');
const Member MEMBER_BINARY_OPERATOR = tuple(KIND_BINARY_EXPRESSION, 'binary_operator');
const Member MEMBER_BINARY_RIGHT_OPERAND = tuple(KIND_BINARY_EXPRESSION, 'binary_right_operand');
const Member MEMBER_BRACED_EXPRESSION_EXPRESSION = tuple(KIND_BRACED_EXPRESSION, 'braced_expression_expression');
const Member MEMBER_BRACED_EXPRESSION_LEFT_BRACE = tuple(KIND_BRACED_EXPRESSION, 'braced_expression_left_brace');
const Member MEMBER_BRACED_EXPRESSION_RIGHT_BRACE = tuple(KIND_BRACED_EXPRESSION, 'braced_expression_right_brace');
const Member MEMBER_BREAK_KEYWORD = tuple(KIND_BREAK_STATEMENT, 'break_keyword');
const Member MEMBER_BREAK_SEMICOLON = tuple(KIND_BREAK_STATEMENT, 'break_semicolon');
const Member MEMBER_CASE_COLON = tuple(KIND_CASE_LABEL, 'case_colon');
const Member MEMBER_CASE_EXPRESSION = tuple(KIND_CASE_LABEL, 'case_expression');
const Member MEMBER_CASE_KEYWORD = tuple(KIND_CASE_LABEL, 'case_keyword');
const Member MEMBER_CAST_LEFT_PAREN = tuple(KIND_CAST_EXPRESSION, 'cast_left_paren');
const Member MEMBER_CAST_OPERAND = tuple(KIND_CAST_EXPRESSION, 'cast_operand');
const Member MEMBER_CAST_RIGHT_PAREN = tuple(KIND_CAST_EXPRESSION, 'cast_right_paren');
const Member MEMBER_CAST_TYPE = tuple(KIND_CAST_EXPRESSION, 'cast_type');
const Member MEMBER_CATCH_BODY = tuple(KIND_CATCH_CLAUSE, 'catch_body');
const Member MEMBER_CATCH_KEYWORD = tuple(KIND_CATCH_CLAUSE, 'catch_keyword');
const Member MEMBER_CATCH_LEFT_PAREN = tuple(KIND_CATCH_CLAUSE, 'catch_left_paren');
const Member MEMBER_CATCH_RIGHT_PAREN = tuple(KIND_CATCH_CLAUSE, 'catch_right_paren');
const Member MEMBER_CATCH_TYPE = tuple(KIND_CATCH_CLAUSE, 'catch_type');
const Member MEMBER_CATCH_VARIABLE = tuple(KIND_CATCH_CLAUSE, 'catch_variable');
const Member MEMBER_CLASSISH_ATTRIBUTE = tuple(KIND_CLASSISH_DECLARATION, 'classish_attribute');
const Member MEMBER_CLASSISH_BODY = tuple(KIND_CLASSISH_DECLARATION, 'classish_body');
const Member MEMBER_CLASSISH_BODY_ELEMENTS = tuple(KIND_CLASSISH_BODY, 'classish_body_elements');
const Member MEMBER_CLASSISH_BODY_LEFT_BRACE = tuple(KIND_CLASSISH_BODY, 'classish_body_left_brace');
const Member MEMBER_CLASSISH_BODY_RIGHT_BRACE = tuple(KIND_CLASSISH_BODY, 'classish_body_right_brace');
const Member MEMBER_CLASSISH_EXTENDS_KEYWORD = tuple(KIND_CLASSISH_DECLARATION, 'classish_extends_keyword');
const Member MEMBER_CLASSISH_EXTENDS_LIST = tuple(KIND_CLASSISH_DECLARATION, 'classish_extends_list');
const Member MEMBER_CLASSISH_IMPLEMENTS_KEYWORD = tuple(KIND_CLASSISH_DECLARATION, 'classish_implements_keyword');
const Member MEMBER_CLASSISH_IMPLEMENTS_LIST = tuple(KIND_CLASSISH_DECLARATION, 'classish_implements_list');
const Member MEMBER_CLASSISH_KEYWORD = tuple(KIND_CLASSISH_DECLARATION, 'classish_keyword');
const Member MEMBER_CLASSISH_MODIFIERS = tuple(KIND_CLASSISH_DECLARATION, 'classish_modifiers');
const Member MEMBER_CLASSISH_NAME = tuple(KIND_CLASSISH_DECLARATION, 'classish_name');
const Member MEMBER_CLASSISH_TYPE_PARAMETERS = tuple(KIND_CLASSISH_DECLARATION, 'classish_type_parameters');
const Member MEMBER_CLASSISH_WHERE_CLAUSE = tuple(KIND_CLASSISH_DECLARATION, 'classish_where_clause');
const Member MEMBER_CLASSISH_XHP = tuple(KIND_CLASSISH_DECLARATION, 'classish_xhp');
const Member MEMBER_CLASSNAME_KEYWORD = tuple(KIND_CLASSNAME_TYPE_SPECIFIER, 'classname_keyword');
const Member MEMBER_CLASSNAME_LEFT_ANGLE = tuple(KIND_CLASSNAME_TYPE_SPECIFIER, 'classname_left_angle');
const Member MEMBER_CLASSNAME_RIGHT_ANGLE = tuple(KIND_CLASSNAME_TYPE_SPECIFIER, 'classname_right_angle');
const Member MEMBER_CLASSNAME_TRAILING_COMMA = tuple(KIND_CLASSNAME_TYPE_SPECIFIER, 'classname_trailing_comma');
const Member MEMBER_CLASSNAME_TYPE = tuple(KIND_CLASSNAME_TYPE_SPECIFIER, 'classname_type');
const Member MEMBER_CLOSURE_COLON = tuple(KIND_CLOSURE_TYPE_SPECIFIER, 'closure_colon');
const Member MEMBER_CLOSURE_CONTEXTS = tuple(KIND_CLOSURE_TYPE_SPECIFIER, 'closure_contexts');
const Member MEMBER_CLOSURE_FUNCTION_KEYWORD = tuple(KIND_CLOSURE_TYPE_SPECIFIER, 'closure_function_keyword');
const Member MEMBER_CLOSURE_INNER_LEFT_PAREN = tuple(KIND_CLOSURE_TYPE_SPECIFIER, 'closure_inner_left_paren');
const Member MEMBER_CLOSURE_INNER_RIGHT_PAREN = tuple(KIND_CLOSURE_TYPE_SPECIFIER, 'closure_inner_right_paren');
const Member MEMBER_CLOSURE_OUTER_LEFT_PAREN = tuple(KIND_CLOSURE_TYPE_SPECIFIER, 'closure_outer_left_paren');
const Member MEMBER_CLOSURE_OUTER_RIGHT_PAREN = tuple(KIND_CLOSURE_TYPE_SPECIFIER, 'closure_outer_right_paren');
const Member MEMBER_CLOSURE_PARAMETER_CALL_CONVENTION = tuple(KIND_CLOSURE_PARAMETER_TYPE_SPECIFIER, 'closure_parameter_call_convention');
const Member MEMBER_CLOSURE_PARAMETER_LIST = tuple(KIND_CLOSURE_TYPE_SPECIFIER, 'closure_parameter_list');
const Member MEMBER_CLOSURE_PARAMETER_READONLY = tuple(KIND_CLOSURE_PARAMETER_TYPE_SPECIFIER, 'closure_parameter_readonly');
const Member MEMBER_CLOSURE_PARAMETER_TYPE = tuple(KIND_CLOSURE_PARAMETER_TYPE_SPECIFIER, 'closure_parameter_type');
const Member MEMBER_CLOSURE_READONLY_KEYWORD = tuple(KIND_CLOSURE_TYPE_SPECIFIER, 'closure_readonly_keyword');
const Member MEMBER_CLOSURE_READONLY_RETURN = tuple(KIND_CLOSURE_TYPE_SPECIFIER, 'closure_readonly_return');
const Member MEMBER_CLOSURE_RETURN_TYPE = tuple(KIND_CLOSURE_TYPE_SPECIFIER, 'closure_return_type');
const Member MEMBER_COLLECTION_LITERAL_INITIALIZERS = tuple(KIND_COLLECTION_LITERAL_EXPRESSION, 'collection_literal_initializers');
const Member MEMBER_COLLECTION_LITERAL_LEFT_BRACE = tuple(KIND_COLLECTION_LITERAL_EXPRESSION, 'collection_literal_left_brace');
const Member MEMBER_COLLECTION_LITERAL_NAME = tuple(KIND_COLLECTION_LITERAL_EXPRESSION, 'collection_literal_name');
const Member MEMBER_COLLECTION_LITERAL_RIGHT_BRACE = tuple(KIND_COLLECTION_LITERAL_EXPRESSION, 'collection_literal_right_brace');
const Member MEMBER_COMPOUND_LEFT_BRACE = tuple(KIND_COMPOUND_STATEMENT, 'compound_left_brace');
const Member MEMBER_COMPOUND_RIGHT_BRACE = tuple(KIND_COMPOUND_STATEMENT, 'compound_right_brace');
const Member MEMBER_COMPOUND_STATEMENTS = tuple(KIND_COMPOUND_STATEMENT, 'compound_statements');
const Member MEMBER_CONCURRENT_KEYWORD = tuple(KIND_CONCURRENT_STATEMENT, 'concurrent_keyword');
const Member MEMBER_CONCURRENT_STATEMENT = tuple(KIND_CONCURRENT_STATEMENT, 'concurrent_statement');
const Member MEMBER_CONDITIONAL_ALTERNATIVE = tuple(KIND_CONDITIONAL_EXPRESSION, 'conditional_alternative');
const Member MEMBER_CONDITIONAL_COLON = tuple(KIND_CONDITIONAL_EXPRESSION, 'conditional_colon');
const Member MEMBER_CONDITIONAL_CONSEQUENCE = tuple(KIND_CONDITIONAL_EXPRESSION, 'conditional_consequence');
const Member MEMBER_CONDITIONAL_QUESTION = tuple(KIND_CONDITIONAL_EXPRESSION, 'conditional_question');
const Member MEMBER_CONDITIONAL_TEST = tuple(KIND_CONDITIONAL_EXPRESSION, 'conditional_test');
const Member MEMBER_CONST_ATTRIBUTE_SPEC = tuple(KIND_CONST_DECLARATION, 'const_attribute_spec');
const Member MEMBER_CONST_DECLARATORS = tuple(KIND_CONST_DECLARATION, 'const_declarators');
const Member MEMBER_CONST_KEYWORD = tuple(KIND_CONST_DECLARATION, 'const_keyword');
const Member MEMBER_CONST_MODIFIERS = tuple(KIND_CONST_DECLARATION, 'const_modifiers');
const Member MEMBER_CONST_SEMICOLON = tuple(KIND_CONST_DECLARATION, 'const_semicolon');
const Member MEMBER_CONST_TYPE_SPECIFIER = tuple(KIND_CONST_DECLARATION, 'const_type_specifier');
const Member MEMBER_CONSTANT_DECLARATOR_INITIALIZER = tuple(KIND_CONSTANT_DECLARATOR, 'constant_declarator_initializer');
const Member MEMBER_CONSTANT_DECLARATOR_NAME = tuple(KIND_CONSTANT_DECLARATOR, 'constant_declarator_name');
const Member MEMBER_CONSTRAINT_KEYWORD = tuple(KIND_TYPE_CONSTRAINT, 'constraint_keyword');
const Member MEMBER_CONSTRAINT_TYPE = tuple(KIND_TYPE_CONSTRAINT, 'constraint_type');
const Member MEMBER_CONSTRUCTOR_CALL_ARGUMENT_LIST = tuple(KIND_CONSTRUCTOR_CALL, 'constructor_call_argument_list');
const Member MEMBER_CONSTRUCTOR_CALL_LEFT_PAREN = tuple(KIND_CONSTRUCTOR_CALL, 'constructor_call_left_paren');
const Member MEMBER_CONSTRUCTOR_CALL_RIGHT_PAREN = tuple(KIND_CONSTRUCTOR_CALL, 'constructor_call_right_paren');
const Member MEMBER_CONSTRUCTOR_CALL_TYPE = tuple(KIND_CONSTRUCTOR_CALL, 'constructor_call_type');
const Member MEMBER_CONTEXT_CONST_CONST_KEYWORD = tuple(KIND_CONTEXT_CONST_DECLARATION, 'context_const_const_keyword');
const Member MEMBER_CONTEXT_CONST_CONSTRAINT = tuple(KIND_CONTEXT_CONST_DECLARATION, 'context_const_constraint');
const Member MEMBER_CONTEXT_CONST_CTX_KEYWORD = tuple(KIND_CONTEXT_CONST_DECLARATION, 'context_const_ctx_keyword');
const Member MEMBER_CONTEXT_CONST_CTX_LIST = tuple(KIND_CONTEXT_CONST_DECLARATION, 'context_const_ctx_list');
const Member MEMBER_CONTEXT_CONST_EQUAL = tuple(KIND_CONTEXT_CONST_DECLARATION, 'context_const_equal');
const Member MEMBER_CONTEXT_CONST_MODIFIERS = tuple(KIND_CONTEXT_CONST_DECLARATION, 'context_const_modifiers');
const Member MEMBER_CONTEXT_CONST_NAME = tuple(KIND_CONTEXT_CONST_DECLARATION, 'context_const_name');
const Member MEMBER_CONTEXT_CONST_SEMICOLON = tuple(KIND_CONTEXT_CONST_DECLARATION, 'context_const_semicolon');
const Member MEMBER_CONTEXT_CONST_TYPE_PARAMETERS = tuple(KIND_CONTEXT_CONST_DECLARATION, 'context_const_type_parameters');
const Member MEMBER_CONTEXTS_LEFT_BRACKET = tuple(KIND_CONTEXTS, 'contexts_left_bracket');
const Member MEMBER_CONTEXTS_RIGHT_BRACKET = tuple(KIND_CONTEXTS, 'contexts_right_bracket');
const Member MEMBER_CONTEXTS_TYPES = tuple(KIND_CONTEXTS, 'contexts_types');
const Member MEMBER_CONTINUE_KEYWORD = tuple(KIND_CONTINUE_STATEMENT, 'continue_keyword');
const Member MEMBER_CONTINUE_SEMICOLON = tuple(KIND_CONTINUE_STATEMENT, 'continue_semicolon');
const Member MEMBER_CTX_ALIAS_AS_CONSTRAINT = tuple(KIND_CONTEXT_ALIAS_DECLARATION, 'ctx_alias_as_constraint');
const Member MEMBER_CTX_ALIAS_ATTRIBUTE_SPEC = tuple(KIND_CONTEXT_ALIAS_DECLARATION, 'ctx_alias_attribute_spec');
const Member MEMBER_CTX_ALIAS_CONTEXT = tuple(KIND_CONTEXT_ALIAS_DECLARATION, 'ctx_alias_context');
const Member MEMBER_CTX_ALIAS_EQUAL = tuple(KIND_CONTEXT_ALIAS_DECLARATION, 'ctx_alias_equal');
const Member MEMBER_CTX_ALIAS_GENERIC_PARAMETER = tuple(KIND_CONTEXT_ALIAS_DECLARATION, 'ctx_alias_generic_parameter');
const Member MEMBER_CTX_ALIAS_KEYWORD = tuple(KIND_CONTEXT_ALIAS_DECLARATION, 'ctx_alias_keyword');
const Member MEMBER_CTX_ALIAS_NAME = tuple(KIND_CONTEXT_ALIAS_DECLARATION, 'ctx_alias_name');
const Member MEMBER_CTX_ALIAS_SEMICOLON = tuple(KIND_CONTEXT_ALIAS_DECLARATION, 'ctx_alias_semicolon');
const Member MEMBER_CTX_CONSTRAINT_CTX_LIST = tuple(KIND_CONTEXT_CONSTRAINT, 'ctx_constraint_ctx_list');
const Member MEMBER_CTX_CONSTRAINT_KEYWORD = tuple(KIND_CONTEXT_CONSTRAINT, 'ctx_constraint_keyword');
const Member MEMBER_CTX_IN_REFINEMENT_CONSTRAINTS = tuple(KIND_CTX_IN_REFINEMENT, 'ctx_in_refinement_constraints');
const Member MEMBER_CTX_IN_REFINEMENT_CTX_LIST = tuple(KIND_CTX_IN_REFINEMENT, 'ctx_in_refinement_ctx_list');
const Member MEMBER_CTX_IN_REFINEMENT_EQUAL = tuple(KIND_CTX_IN_REFINEMENT, 'ctx_in_refinement_equal');
const Member MEMBER_CTX_IN_REFINEMENT_KEYWORD = tuple(KIND_CTX_IN_REFINEMENT, 'ctx_in_refinement_keyword');
const Member MEMBER_CTX_IN_REFINEMENT_NAME = tuple(KIND_CTX_IN_REFINEMENT, 'ctx_in_refinement_name');
const Member MEMBER_CTX_IN_REFINEMENT_TYPE_PARAMETERS = tuple(KIND_CTX_IN_REFINEMENT, 'ctx_in_refinement_type_parameters');
const Member MEMBER_DARRAY_COMMA = tuple(KIND_DARRAY_TYPE_SPECIFIER, 'darray_comma');
const Member MEMBER_DARRAY_INTRINSIC_EXPLICIT_TYPE = tuple(KIND_DARRAY_INTRINSIC_EXPRESSION, 'darray_intrinsic_explicit_type');
const Member MEMBER_DARRAY_INTRINSIC_KEYWORD = tuple(KIND_DARRAY_INTRINSIC_EXPRESSION, 'darray_intrinsic_keyword');
const Member MEMBER_DARRAY_INTRINSIC_LEFT_BRACKET = tuple(KIND_DARRAY_INTRINSIC_EXPRESSION, 'darray_intrinsic_left_bracket');
const Member MEMBER_DARRAY_INTRINSIC_MEMBERS = tuple(KIND_DARRAY_INTRINSIC_EXPRESSION, 'darray_intrinsic_members');
const Member MEMBER_DARRAY_INTRINSIC_RIGHT_BRACKET = tuple(KIND_DARRAY_INTRINSIC_EXPRESSION, 'darray_intrinsic_right_bracket');
const Member MEMBER_DARRAY_KEY = tuple(KIND_DARRAY_TYPE_SPECIFIER, 'darray_key');
const Member MEMBER_DARRAY_KEYWORD = tuple(KIND_DARRAY_TYPE_SPECIFIER, 'darray_keyword');
const Member MEMBER_DARRAY_LEFT_ANGLE = tuple(KIND_DARRAY_TYPE_SPECIFIER, 'darray_left_angle');
const Member MEMBER_DARRAY_RIGHT_ANGLE = tuple(KIND_DARRAY_TYPE_SPECIFIER, 'darray_right_angle');
const Member MEMBER_DARRAY_TRAILING_COMMA = tuple(KIND_DARRAY_TYPE_SPECIFIER, 'darray_trailing_comma');
const Member MEMBER_DARRAY_VALUE = tuple(KIND_DARRAY_TYPE_SPECIFIER, 'darray_value');
const Member MEMBER_DECORATED_EXPRESSION_DECORATOR = tuple(KIND_DECORATED_EXPRESSION, 'decorated_expression_decorator');
const Member MEMBER_DECORATED_EXPRESSION_EXPRESSION = tuple(KIND_DECORATED_EXPRESSION, 'decorated_expression_expression');
const Member MEMBER_DEFAULT_COLON = tuple(KIND_DEFAULT_LABEL, 'default_colon');
const Member MEMBER_DEFAULT_KEYWORD = tuple(KIND_DEFAULT_LABEL, 'default_keyword');
const Member MEMBER_DEFINE_ARGUMENT_LIST = tuple(KIND_DEFINE_EXPRESSION, 'define_argument_list');
const Member MEMBER_DEFINE_KEYWORD = tuple(KIND_DEFINE_EXPRESSION, 'define_keyword');
const Member MEMBER_DEFINE_LEFT_PAREN = tuple(KIND_DEFINE_EXPRESSION, 'define_left_paren');
const Member MEMBER_DEFINE_RIGHT_PAREN = tuple(KIND_DEFINE_EXPRESSION, 'define_right_paren');
const Member MEMBER_DICTIONARY_INTRINSIC_EXPLICIT_TYPE = tuple(KIND_DICTIONARY_INTRINSIC_EXPRESSION, 'dictionary_intrinsic_explicit_type');
const Member MEMBER_DICTIONARY_INTRINSIC_KEYWORD = tuple(KIND_DICTIONARY_INTRINSIC_EXPRESSION, 'dictionary_intrinsic_keyword');
const Member MEMBER_DICTIONARY_INTRINSIC_LEFT_BRACKET = tuple(KIND_DICTIONARY_INTRINSIC_EXPRESSION, 'dictionary_intrinsic_left_bracket');
const Member MEMBER_DICTIONARY_INTRINSIC_MEMBERS = tuple(KIND_DICTIONARY_INTRINSIC_EXPRESSION, 'dictionary_intrinsic_members');
const Member MEMBER_DICTIONARY_INTRINSIC_RIGHT_BRACKET = tuple(KIND_DICTIONARY_INTRINSIC_EXPRESSION, 'dictionary_intrinsic_right_bracket');
const Member MEMBER_DICTIONARY_TYPE_KEYWORD = tuple(KIND_DICTIONARY_TYPE_SPECIFIER, 'dictionary_type_keyword');
const Member MEMBER_DICTIONARY_TYPE_LEFT_ANGLE = tuple(KIND_DICTIONARY_TYPE_SPECIFIER, 'dictionary_type_left_angle');
const Member MEMBER_DICTIONARY_TYPE_MEMBERS = tuple(KIND_DICTIONARY_TYPE_SPECIFIER, 'dictionary_type_members');
const Member MEMBER_DICTIONARY_TYPE_RIGHT_ANGLE = tuple(KIND_DICTIONARY_TYPE_SPECIFIER, 'dictionary_type_right_angle');
const Member MEMBER_DO_BODY = tuple(KIND_DO_STATEMENT, 'do_body');
const Member MEMBER_DO_CONDITION = tuple(KIND_DO_STATEMENT, 'do_condition');
const Member MEMBER_DO_KEYWORD = tuple(KIND_DO_STATEMENT, 'do_keyword');
const Member MEMBER_DO_LEFT_PAREN = tuple(KIND_DO_STATEMENT, 'do_left_paren');
const Member MEMBER_DO_RIGHT_PAREN = tuple(KIND_DO_STATEMENT, 'do_right_paren');
const Member MEMBER_DO_SEMICOLON = tuple(KIND_DO_STATEMENT, 'do_semicolon');
const Member MEMBER_DO_WHILE_KEYWORD = tuple(KIND_DO_STATEMENT, 'do_while_keyword');
const Member MEMBER_ECHO_EXPRESSIONS = tuple(KIND_ECHO_STATEMENT, 'echo_expressions');
const Member MEMBER_ECHO_KEYWORD = tuple(KIND_ECHO_STATEMENT, 'echo_keyword');
const Member MEMBER_ECHO_SEMICOLON = tuple(KIND_ECHO_STATEMENT, 'echo_semicolon');
const Member MEMBER_ELEMENT_ARROW = tuple(KIND_ELEMENT_INITIALIZER, 'element_arrow');
const Member MEMBER_ELEMENT_KEY = tuple(KIND_ELEMENT_INITIALIZER, 'element_key');
const Member MEMBER_ELEMENT_VALUE = tuple(KIND_ELEMENT_INITIALIZER, 'element_value');
const Member MEMBER_ELSE_KEYWORD = tuple(KIND_ELSE_CLAUSE, 'else_keyword');
const Member MEMBER_ELSE_STATEMENT = tuple(KIND_ELSE_CLAUSE, 'else_statement');
const Member MEMBER_ELSEIF_CONDITION = tuple(KIND_ELSEIF_CLAUSE, 'elseif_condition');
const Member MEMBER_ELSEIF_KEYWORD = tuple(KIND_ELSEIF_CLAUSE, 'elseif_keyword');
const Member MEMBER_ELSEIF_LEFT_PAREN = tuple(KIND_ELSEIF_CLAUSE, 'elseif_left_paren');
const Member MEMBER_ELSEIF_RIGHT_PAREN = tuple(KIND_ELSEIF_CLAUSE, 'elseif_right_paren');
const Member MEMBER_ELSEIF_STATEMENT = tuple(KIND_ELSEIF_CLAUSE, 'elseif_statement');
const Member MEMBER_EMBEDDED_BRACED_EXPRESSION_EXPRESSION = tuple(KIND_EMBEDDED_BRACED_EXPRESSION, 'embedded_braced_expression_expression');
const Member MEMBER_EMBEDDED_BRACED_EXPRESSION_LEFT_BRACE = tuple(KIND_EMBEDDED_BRACED_EXPRESSION, 'embedded_braced_expression_left_brace');
const Member MEMBER_EMBEDDED_BRACED_EXPRESSION_RIGHT_BRACE = tuple(KIND_EMBEDDED_BRACED_EXPRESSION, 'embedded_braced_expression_right_brace');
const Member MEMBER_EMBEDDED_MEMBER_NAME = tuple(KIND_EMBEDDED_MEMBER_SELECTION_EXPRESSION, 'embedded_member_name');
const Member MEMBER_EMBEDDED_MEMBER_OBJECT = tuple(KIND_EMBEDDED_MEMBER_SELECTION_EXPRESSION, 'embedded_member_object');
const Member MEMBER_EMBEDDED_MEMBER_OPERATOR = tuple(KIND_EMBEDDED_MEMBER_SELECTION_EXPRESSION, 'embedded_member_operator');
const Member MEMBER_EMBEDDED_SUBSCRIPT_INDEX = tuple(KIND_EMBEDDED_SUBSCRIPT_EXPRESSION, 'embedded_subscript_index');
const Member MEMBER_EMBEDDED_SUBSCRIPT_LEFT_BRACKET = tuple(KIND_EMBEDDED_SUBSCRIPT_EXPRESSION, 'embedded_subscript_left_bracket');
const Member MEMBER_EMBEDDED_SUBSCRIPT_RECEIVER = tuple(KIND_EMBEDDED_SUBSCRIPT_EXPRESSION, 'embedded_subscript_receiver');
const Member MEMBER_EMBEDDED_SUBSCRIPT_RIGHT_BRACKET = tuple(KIND_EMBEDDED_SUBSCRIPT_EXPRESSION, 'embedded_subscript_right_bracket');
const Member MEMBER_END_OF_FILE_TOKEN = tuple(KIND_END_OF_FILE, 'end_of_file_token');
const Member MEMBER_ENUM_ATOM_EXPRESSION = tuple(KIND_ENUM_ATOM_EXPRESSION, 'enum_atom_expression');
const Member MEMBER_ENUM_ATOM_HASH = tuple(KIND_ENUM_ATOM_EXPRESSION, 'enum_atom_hash');
const Member MEMBER_ENUM_ATTRIBUTE_SPEC = tuple(KIND_ENUM_DECLARATION, 'enum_attribute_spec');
const Member MEMBER_ENUM_BASE = tuple(KIND_ENUM_DECLARATION, 'enum_base');
const Member MEMBER_ENUM_CLASS_ATTRIBUTE_SPEC = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_attribute_spec');
const Member MEMBER_ENUM_CLASS_BASE = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_base');
const Member MEMBER_ENUM_CLASS_CLASS_KEYWORD = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_class_keyword');
const Member MEMBER_ENUM_CLASS_COLON = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_colon');
const Member MEMBER_ENUM_CLASS_ELEMENTS = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_elements');
const Member MEMBER_ENUM_CLASS_ENUM_KEYWORD = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_enum_keyword');
const Member MEMBER_ENUM_CLASS_ENUMERATOR_EQUAL = tuple(KIND_ENUM_CLASS_ENUMERATOR, 'enum_class_enumerator_equal');
const Member MEMBER_ENUM_CLASS_ENUMERATOR_INITIAL_VALUE = tuple(KIND_ENUM_CLASS_ENUMERATOR, 'enum_class_enumerator_initial_value');
const Member MEMBER_ENUM_CLASS_ENUMERATOR_INITIALIZER = tuple(KIND_ENUM_CLASS_ENUMERATOR, 'enum_class_enumerator_initializer');
const Member MEMBER_ENUM_CLASS_ENUMERATOR_MODIFIERS = tuple(KIND_ENUM_CLASS_ENUMERATOR, 'enum_class_enumerator_modifiers');
const Member MEMBER_ENUM_CLASS_ENUMERATOR_NAME = tuple(KIND_ENUM_CLASS_ENUMERATOR, 'enum_class_enumerator_name');
const Member MEMBER_ENUM_CLASS_ENUMERATOR_SEMICOLON = tuple(KIND_ENUM_CLASS_ENUMERATOR, 'enum_class_enumerator_semicolon');
const Member MEMBER_ENUM_CLASS_ENUMERATOR_TYPE = tuple(KIND_ENUM_CLASS_ENUMERATOR, 'enum_class_enumerator_type');
const Member MEMBER_ENUM_CLASS_EXTENDS = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_extends');
const Member MEMBER_ENUM_CLASS_EXTENDS_LIST = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_extends_list');
const Member MEMBER_ENUM_CLASS_LABEL_EXPRESSION = tuple(KIND_ENUM_CLASS_LABEL_EXPRESSION, 'enum_class_label_expression');
const Member MEMBER_ENUM_CLASS_LABEL_HASH = tuple(KIND_ENUM_CLASS_LABEL_EXPRESSION, 'enum_class_label_hash');
const Member MEMBER_ENUM_CLASS_LABEL_QUALIFIER = tuple(KIND_ENUM_CLASS_LABEL_EXPRESSION, 'enum_class_label_qualifier');
const Member MEMBER_ENUM_CLASS_LEFT_BRACE = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_left_brace');
const Member MEMBER_ENUM_CLASS_MODIFIERS = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_modifiers');
const Member MEMBER_ENUM_CLASS_NAME = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_name');
const Member MEMBER_ENUM_CLASS_RIGHT_BRACE = tuple(KIND_ENUM_CLASS_DECLARATION, 'enum_class_right_brace');
const Member MEMBER_ENUM_COLON = tuple(KIND_ENUM_DECLARATION, 'enum_colon');
const Member MEMBER_ENUM_ENUMERATORS = tuple(KIND_ENUM_DECLARATION, 'enum_enumerators');
const Member MEMBER_ENUM_KEYWORD = tuple(KIND_ENUM_DECLARATION, 'enum_keyword');
const Member MEMBER_ENUM_LEFT_BRACE = tuple(KIND_ENUM_DECLARATION, 'enum_left_brace');
const Member MEMBER_ENUM_MODIFIERS = tuple(KIND_ENUM_DECLARATION, 'enum_modifiers');
const Member MEMBER_ENUM_NAME = tuple(KIND_ENUM_DECLARATION, 'enum_name');
const Member MEMBER_ENUM_RIGHT_BRACE = tuple(KIND_ENUM_DECLARATION, 'enum_right_brace');
const Member MEMBER_ENUM_TYPE = tuple(KIND_ENUM_DECLARATION, 'enum_type');
const Member MEMBER_ENUM_USE_CLAUSES = tuple(KIND_ENUM_DECLARATION, 'enum_use_clauses');
const Member MEMBER_ENUM_USE_KEYWORD = tuple(KIND_ENUM_USE, 'enum_use_keyword');
const Member MEMBER_ENUM_USE_NAMES = tuple(KIND_ENUM_USE, 'enum_use_names');
const Member MEMBER_ENUM_USE_SEMICOLON = tuple(KIND_ENUM_USE, 'enum_use_semicolon');
const Member MEMBER_ENUMERATOR_EQUAL = tuple(KIND_ENUMERATOR, 'enumerator_equal');
const Member MEMBER_ENUMERATOR_NAME = tuple(KIND_ENUMERATOR, 'enumerator_name');
const Member MEMBER_ENUMERATOR_SEMICOLON = tuple(KIND_ENUMERATOR, 'enumerator_semicolon');
const Member MEMBER_ENUMERATOR_VALUE = tuple(KIND_ENUMERATOR, 'enumerator_value');
const Member MEMBER_ERROR_ERROR = tuple(KIND_ERROR_SYNTAX, 'error_error');
const Member MEMBER_ET_SPLICE_EXPRESSION_DOLLAR = tuple(KIND_ETSPLICE_EXPRESSION, 'et_splice_expression_dollar');
const Member MEMBER_ET_SPLICE_EXPRESSION_EXPRESSION = tuple(KIND_ETSPLICE_EXPRESSION, 'et_splice_expression_expression');
const Member MEMBER_ET_SPLICE_EXPRESSION_LEFT_BRACE = tuple(KIND_ETSPLICE_EXPRESSION, 'et_splice_expression_left_brace');
const Member MEMBER_ET_SPLICE_EXPRESSION_RIGHT_BRACE = tuple(KIND_ETSPLICE_EXPRESSION, 'et_splice_expression_right_brace');
const Member MEMBER_EVAL_ARGUMENT = tuple(KIND_EVAL_EXPRESSION, 'eval_argument');
const Member MEMBER_EVAL_KEYWORD = tuple(KIND_EVAL_EXPRESSION, 'eval_keyword');
const Member MEMBER_EVAL_LEFT_PAREN = tuple(KIND_EVAL_EXPRESSION, 'eval_left_paren');
const Member MEMBER_EVAL_RIGHT_PAREN = tuple(KIND_EVAL_EXPRESSION, 'eval_right_paren');
const Member MEMBER_EXPRESSION_STATEMENT_EXPRESSION = tuple(KIND_EXPRESSION_STATEMENT, 'expression_statement_expression');
const Member MEMBER_EXPRESSION_STATEMENT_SEMICOLON = tuple(KIND_EXPRESSION_STATEMENT, 'expression_statement_semicolon');
const Member MEMBER_FALLTHROUGH_KEYWORD = tuple(KIND_SWITCH_FALLTHROUGH, 'fallthrough_keyword');
const Member MEMBER_FALLTHROUGH_SEMICOLON = tuple(KIND_SWITCH_FALLTHROUGH, 'fallthrough_semicolon');
const Member MEMBER_FIELD_ARROW = tuple(KIND_FIELD_SPECIFIER, 'field_arrow');
const Member MEMBER_FIELD_INITIALIZER_ARROW = tuple(KIND_FIELD_INITIALIZER, 'field_initializer_arrow');
const Member MEMBER_FIELD_INITIALIZER_NAME = tuple(KIND_FIELD_INITIALIZER, 'field_initializer_name');
const Member MEMBER_FIELD_INITIALIZER_VALUE = tuple(KIND_FIELD_INITIALIZER, 'field_initializer_value');
const Member MEMBER_FIELD_NAME = tuple(KIND_FIELD_SPECIFIER, 'field_name');
const Member MEMBER_FIELD_QUESTION = tuple(KIND_FIELD_SPECIFIER, 'field_question');
const Member MEMBER_FIELD_TYPE = tuple(KIND_FIELD_SPECIFIER, 'field_type');
const Member MEMBER_FILE_ATTRIBUTE_SPECIFICATION_ATTRIBUTES = tuple(KIND_FILE_ATTRIBUTE_SPECIFICATION, 'file_attribute_specification_attributes');
const Member MEMBER_FILE_ATTRIBUTE_SPECIFICATION_COLON = tuple(KIND_FILE_ATTRIBUTE_SPECIFICATION, 'file_attribute_specification_colon');
const Member MEMBER_FILE_ATTRIBUTE_SPECIFICATION_KEYWORD = tuple(KIND_FILE_ATTRIBUTE_SPECIFICATION, 'file_attribute_specification_keyword');
const Member MEMBER_FILE_ATTRIBUTE_SPECIFICATION_LEFT_DOUBLE_ANGLE = tuple(KIND_FILE_ATTRIBUTE_SPECIFICATION, 'file_attribute_specification_left_double_angle');
const Member MEMBER_FILE_ATTRIBUTE_SPECIFICATION_RIGHT_DOUBLE_ANGLE = tuple(KIND_FILE_ATTRIBUTE_SPECIFICATION, 'file_attribute_specification_right_double_angle');
const Member MEMBER_FINALLY_BODY = tuple(KIND_FINALLY_CLAUSE, 'finally_body');
const Member MEMBER_FINALLY_KEYWORD = tuple(KIND_FINALLY_CLAUSE, 'finally_keyword');
const Member MEMBER_FOR_BODY = tuple(KIND_FOR_STATEMENT, 'for_body');
const Member MEMBER_FOR_CONTROL = tuple(KIND_FOR_STATEMENT, 'for_control');
const Member MEMBER_FOR_END_OF_LOOP = tuple(KIND_FOR_STATEMENT, 'for_end_of_loop');
const Member MEMBER_FOR_FIRST_SEMICOLON = tuple(KIND_FOR_STATEMENT, 'for_first_semicolon');
const Member MEMBER_FOR_INITIALIZER = tuple(KIND_FOR_STATEMENT, 'for_initializer');
const Member MEMBER_FOR_KEYWORD = tuple(KIND_FOR_STATEMENT, 'for_keyword');
const Member MEMBER_FOR_LEFT_PAREN = tuple(KIND_FOR_STATEMENT, 'for_left_paren');
const Member MEMBER_FOR_RIGHT_PAREN = tuple(KIND_FOR_STATEMENT, 'for_right_paren');
const Member MEMBER_FOR_SECOND_SEMICOLON = tuple(KIND_FOR_STATEMENT, 'for_second_semicolon');
const Member MEMBER_FOREACH_ARROW = tuple(KIND_FOREACH_STATEMENT, 'foreach_arrow');
const Member MEMBER_FOREACH_AS = tuple(KIND_FOREACH_STATEMENT, 'foreach_as');
const Member MEMBER_FOREACH_AWAIT_KEYWORD = tuple(KIND_FOREACH_STATEMENT, 'foreach_await_keyword');
const Member MEMBER_FOREACH_BODY = tuple(KIND_FOREACH_STATEMENT, 'foreach_body');
const Member MEMBER_FOREACH_COLLECTION = tuple(KIND_FOREACH_STATEMENT, 'foreach_collection');
const Member MEMBER_FOREACH_KEY = tuple(KIND_FOREACH_STATEMENT, 'foreach_key');
const Member MEMBER_FOREACH_KEYWORD = tuple(KIND_FOREACH_STATEMENT, 'foreach_keyword');
const Member MEMBER_FOREACH_LEFT_PAREN = tuple(KIND_FOREACH_STATEMENT, 'foreach_left_paren');
const Member MEMBER_FOREACH_RIGHT_PAREN = tuple(KIND_FOREACH_STATEMENT, 'foreach_right_paren');
const Member MEMBER_FOREACH_VALUE = tuple(KIND_FOREACH_STATEMENT, 'foreach_value');
const Member MEMBER_FUNCTION_ATTRIBUTE_SPEC = tuple(KIND_FUNCTION_DECLARATION, 'function_attribute_spec');
const Member MEMBER_FUNCTION_BODY = tuple(KIND_FUNCTION_DECLARATION, 'function_body');
const Member MEMBER_FUNCTION_CALL_ARGUMENT_LIST = tuple(KIND_FUNCTION_CALL_EXPRESSION, 'function_call_argument_list');
const Member MEMBER_FUNCTION_CALL_ENUM_ATOM = tuple(KIND_FUNCTION_CALL_EXPRESSION, 'function_call_enum_atom');
const Member MEMBER_FUNCTION_CALL_ENUM_CLASS_LABEL = tuple(KIND_FUNCTION_CALL_EXPRESSION, 'function_call_enum_class_label');
const Member MEMBER_FUNCTION_CALL_LEFT_PAREN = tuple(KIND_FUNCTION_CALL_EXPRESSION, 'function_call_left_paren');
const Member MEMBER_FUNCTION_CALL_RECEIVER = tuple(KIND_FUNCTION_CALL_EXPRESSION, 'function_call_receiver');
const Member MEMBER_FUNCTION_CALL_RIGHT_PAREN = tuple(KIND_FUNCTION_CALL_EXPRESSION, 'function_call_right_paren');
const Member MEMBER_FUNCTION_CALL_TYPE_ARGS = tuple(KIND_FUNCTION_CALL_EXPRESSION, 'function_call_type_args');
const Member MEMBER_FUNCTION_COLON = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_colon');
const Member MEMBER_FUNCTION_CONTEXTS = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_contexts');
const Member MEMBER_FUNCTION_CTX_TYPE_KEYWORD = tuple(KIND_FUNCTION_CTX_TYPE_SPECIFIER, 'function_ctx_type_keyword');
const Member MEMBER_FUNCTION_CTX_TYPE_VARIABLE = tuple(KIND_FUNCTION_CTX_TYPE_SPECIFIER, 'function_ctx_type_variable');
const Member MEMBER_FUNCTION_DECLARATION_HEADER = tuple(KIND_FUNCTION_DECLARATION, 'function_declaration_header');
const Member MEMBER_FUNCTION_KEYWORD = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_keyword');
const Member MEMBER_FUNCTION_LEFT_PAREN = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_left_paren');
const Member MEMBER_FUNCTION_MODIFIERS = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_modifiers');
const Member MEMBER_FUNCTION_NAME = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_name');
const Member MEMBER_FUNCTION_PARAMETER_LIST = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_parameter_list');
const Member MEMBER_FUNCTION_POINTER_RECEIVER = tuple(KIND_FUNCTION_POINTER_EXPRESSION, 'function_pointer_receiver');
const Member MEMBER_FUNCTION_POINTER_TYPE_ARGS = tuple(KIND_FUNCTION_POINTER_EXPRESSION, 'function_pointer_type_args');
const Member MEMBER_FUNCTION_READONLY_RETURN = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_readonly_return');
const Member MEMBER_FUNCTION_RIGHT_PAREN = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_right_paren');
const Member MEMBER_FUNCTION_TYPE = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_type');
const Member MEMBER_FUNCTION_TYPE_PARAMETER_LIST = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_type_parameter_list');
const Member MEMBER_FUNCTION_WHERE_CLAUSE = tuple(KIND_FUNCTION_DECLARATION_HEADER, 'function_where_clause');
const Member MEMBER_GENERIC_ARGUMENT_LIST = tuple(KIND_GENERIC_TYPE_SPECIFIER, 'generic_argument_list');
const Member MEMBER_GENERIC_CLASS_TYPE = tuple(KIND_GENERIC_TYPE_SPECIFIER, 'generic_class_type');
const Member MEMBER_IF_CONDITION = tuple(KIND_IF_STATEMENT, 'if_condition');
const Member MEMBER_IF_ELSE_CLAUSE = tuple(KIND_IF_STATEMENT, 'if_else_clause');
const Member MEMBER_IF_ELSEIF_CLAUSES = tuple(KIND_IF_STATEMENT, 'if_elseif_clauses');
const Member MEMBER_IF_KEYWORD = tuple(KIND_IF_STATEMENT, 'if_keyword');
const Member MEMBER_IF_LEFT_PAREN = tuple(KIND_IF_STATEMENT, 'if_left_paren');
const Member MEMBER_IF_RIGHT_PAREN = tuple(KIND_IF_STATEMENT, 'if_right_paren');
const Member MEMBER_IF_STATEMENT = tuple(KIND_IF_STATEMENT, 'if_statement');
const Member MEMBER_INCLUSION_EXPRESSION = tuple(KIND_INCLUSION_DIRECTIVE, 'inclusion_expression');
const Member MEMBER_INCLUSION_FILENAME = tuple(KIND_INCLUSION_EXPRESSION, 'inclusion_filename');
const Member MEMBER_INCLUSION_REQUIRE = tuple(KIND_INCLUSION_EXPRESSION, 'inclusion_require');
const Member MEMBER_INCLUSION_SEMICOLON = tuple(KIND_INCLUSION_DIRECTIVE, 'inclusion_semicolon');
const Member MEMBER_INTERSECTION_LEFT_PAREN = tuple(KIND_INTERSECTION_TYPE_SPECIFIER, 'intersection_left_paren');
const Member MEMBER_INTERSECTION_RIGHT_PAREN = tuple(KIND_INTERSECTION_TYPE_SPECIFIER, 'intersection_right_paren');
const Member MEMBER_INTERSECTION_TYPES = tuple(KIND_INTERSECTION_TYPE_SPECIFIER, 'intersection_types');
const Member MEMBER_IS_LEFT_OPERAND = tuple(KIND_IS_EXPRESSION, 'is_left_operand');
const Member MEMBER_IS_OPERATOR = tuple(KIND_IS_EXPRESSION, 'is_operator');
const Member MEMBER_IS_RIGHT_OPERAND = tuple(KIND_IS_EXPRESSION, 'is_right_operand');
const Member MEMBER_ISSET_ARGUMENT_LIST = tuple(KIND_ISSET_EXPRESSION, 'isset_argument_list');
const Member MEMBER_ISSET_KEYWORD = tuple(KIND_ISSET_EXPRESSION, 'isset_keyword');
const Member MEMBER_ISSET_LEFT_PAREN = tuple(KIND_ISSET_EXPRESSION, 'isset_left_paren');
const Member MEMBER_ISSET_RIGHT_PAREN = tuple(KIND_ISSET_EXPRESSION, 'isset_right_paren');
const Member MEMBER_KEYSET_INTRINSIC_EXPLICIT_TYPE = tuple(KIND_KEYSET_INTRINSIC_EXPRESSION, 'keyset_intrinsic_explicit_type');
const Member MEMBER_KEYSET_INTRINSIC_KEYWORD = tuple(KIND_KEYSET_INTRINSIC_EXPRESSION, 'keyset_intrinsic_keyword');
const Member MEMBER_KEYSET_INTRINSIC_LEFT_BRACKET = tuple(KIND_KEYSET_INTRINSIC_EXPRESSION, 'keyset_intrinsic_left_bracket');
const Member MEMBER_KEYSET_INTRINSIC_MEMBERS = tuple(KIND_KEYSET_INTRINSIC_EXPRESSION, 'keyset_intrinsic_members');
const Member MEMBER_KEYSET_INTRINSIC_RIGHT_BRACKET = tuple(KIND_KEYSET_INTRINSIC_EXPRESSION, 'keyset_intrinsic_right_bracket');
const Member MEMBER_KEYSET_TYPE_KEYWORD = tuple(KIND_KEYSET_TYPE_SPECIFIER, 'keyset_type_keyword');
const Member MEMBER_KEYSET_TYPE_LEFT_ANGLE = tuple(KIND_KEYSET_TYPE_SPECIFIER, 'keyset_type_left_angle');
const Member MEMBER_KEYSET_TYPE_RIGHT_ANGLE = tuple(KIND_KEYSET_TYPE_SPECIFIER, 'keyset_type_right_angle');
const Member MEMBER_KEYSET_TYPE_TRAILING_COMMA = tuple(KIND_KEYSET_TYPE_SPECIFIER, 'keyset_type_trailing_comma');
const Member MEMBER_KEYSET_TYPE_TYPE = tuple(KIND_KEYSET_TYPE_SPECIFIER, 'keyset_type_type');
const Member MEMBER_LAMBDA_ARROW = tuple(KIND_LAMBDA_EXPRESSION, 'lambda_arrow');
const Member MEMBER_LAMBDA_ASYNC = tuple(KIND_LAMBDA_EXPRESSION, 'lambda_async');
const Member MEMBER_LAMBDA_ATTRIBUTE_SPEC = tuple(KIND_LAMBDA_EXPRESSION, 'lambda_attribute_spec');
const Member MEMBER_LAMBDA_BODY = tuple(KIND_LAMBDA_EXPRESSION, 'lambda_body');
const Member MEMBER_LAMBDA_COLON = tuple(KIND_LAMBDA_SIGNATURE, 'lambda_colon');
const Member MEMBER_LAMBDA_CONTEXTS = tuple(KIND_LAMBDA_SIGNATURE, 'lambda_contexts');
const Member MEMBER_LAMBDA_LEFT_PAREN = tuple(KIND_LAMBDA_SIGNATURE, 'lambda_left_paren');
const Member MEMBER_LAMBDA_PARAMETERS = tuple(KIND_LAMBDA_SIGNATURE, 'lambda_parameters');
const Member MEMBER_LAMBDA_READONLY_RETURN = tuple(KIND_LAMBDA_SIGNATURE, 'lambda_readonly_return');
const Member MEMBER_LAMBDA_RIGHT_PAREN = tuple(KIND_LAMBDA_SIGNATURE, 'lambda_right_paren');
const Member MEMBER_LAMBDA_SIGNATURE = tuple(KIND_LAMBDA_EXPRESSION, 'lambda_signature');
const Member MEMBER_LAMBDA_TYPE = tuple(KIND_LAMBDA_SIGNATURE, 'lambda_type');
const Member MEMBER_LIKE_TILDE = tuple(KIND_LIKE_TYPE_SPECIFIER, 'like_tilde');
const Member MEMBER_LIKE_TYPE = tuple(KIND_LIKE_TYPE_SPECIFIER, 'like_type');
const Member MEMBER_LIST_ITEM = tuple(KIND_LIST_ITEM, 'list_item');
const Member MEMBER_LIST_KEYWORD = tuple(KIND_LIST_EXPRESSION, 'list_keyword');
const Member MEMBER_LIST_LEFT_PAREN = tuple(KIND_LIST_EXPRESSION, 'list_left_paren');
const Member MEMBER_LIST_MEMBERS = tuple(KIND_LIST_EXPRESSION, 'list_members');
const Member MEMBER_LIST_RIGHT_PAREN = tuple(KIND_LIST_EXPRESSION, 'list_right_paren');
const Member MEMBER_LIST_SEPARATOR = tuple(KIND_LIST_ITEM, 'list_separator');
const Member MEMBER_LITERAL_EXPRESSION = tuple(KIND_LITERAL, 'literal_expression');
const Member MEMBER_MARKUP_HASHBANG = tuple(KIND_MARKUP_SECTION, 'markup_hashbang');
const Member MEMBER_MARKUP_SUFFIX = tuple(KIND_MARKUP_SECTION, 'markup_suffix');
const Member MEMBER_MARKUP_SUFFIX_LESS_THAN_QUESTION = tuple(KIND_MARKUP_SUFFIX, 'markup_suffix_less_than_question');
const Member MEMBER_MARKUP_SUFFIX_NAME = tuple(KIND_MARKUP_SUFFIX, 'markup_suffix_name');
const Member MEMBER_MEMBER_NAME = tuple(KIND_MEMBER_SELECTION_EXPRESSION, 'member_name');
const Member MEMBER_MEMBER_OBJECT = tuple(KIND_MEMBER_SELECTION_EXPRESSION, 'member_object');
const Member MEMBER_MEMBER_OPERATOR = tuple(KIND_MEMBER_SELECTION_EXPRESSION, 'member_operator');
const Member MEMBER_METHODISH_ATTRIBUTE = tuple(KIND_METHODISH_DECLARATION, 'methodish_attribute');
const Member MEMBER_METHODISH_FUNCTION_BODY = tuple(KIND_METHODISH_DECLARATION, 'methodish_function_body');
const Member MEMBER_METHODISH_FUNCTION_DECL_HEADER = tuple(KIND_METHODISH_DECLARATION, 'methodish_function_decl_header');
const Member MEMBER_METHODISH_SEMICOLON = tuple(KIND_METHODISH_DECLARATION, 'methodish_semicolon');
const Member MEMBER_METHODISH_TRAIT_ATTRIBUTE = tuple(KIND_METHODISH_TRAIT_RESOLUTION, 'methodish_trait_attribute');
const Member MEMBER_METHODISH_TRAIT_EQUAL = tuple(KIND_METHODISH_TRAIT_RESOLUTION, 'methodish_trait_equal');
const Member MEMBER_METHODISH_TRAIT_FUNCTION_DECL_HEADER = tuple(KIND_METHODISH_TRAIT_RESOLUTION, 'methodish_trait_function_decl_header');
const Member MEMBER_METHODISH_TRAIT_NAME = tuple(KIND_METHODISH_TRAIT_RESOLUTION, 'methodish_trait_name');
const Member MEMBER_METHODISH_TRAIT_SEMICOLON = tuple(KIND_METHODISH_TRAIT_RESOLUTION, 'methodish_trait_semicolon');
const Member MEMBER_MODULE_DECLARATION_ATTRIBUTE_SPEC = tuple(KIND_MODULE_DECLARATION, 'module_declaration_attribute_spec');
const Member MEMBER_MODULE_DECLARATION_EXPORTS = tuple(KIND_MODULE_DECLARATION, 'module_declaration_exports');
const Member MEMBER_MODULE_DECLARATION_IMPORTS = tuple(KIND_MODULE_DECLARATION, 'module_declaration_imports');
const Member MEMBER_MODULE_DECLARATION_KEYWORD = tuple(KIND_MODULE_DECLARATION, 'module_declaration_keyword');
const Member MEMBER_MODULE_DECLARATION_LEFT_BRACE = tuple(KIND_MODULE_DECLARATION, 'module_declaration_left_brace');
const Member MEMBER_MODULE_DECLARATION_MODULE_KEYWORD = tuple(KIND_MODULE_DECLARATION, 'module_declaration_module_keyword');
const Member MEMBER_MODULE_DECLARATION_NAME = tuple(KIND_MODULE_DECLARATION, 'module_declaration_name');
const Member MEMBER_MODULE_DECLARATION_NEW_KEYWORD = tuple(KIND_MODULE_DECLARATION, 'module_declaration_new_keyword');
const Member MEMBER_MODULE_DECLARATION_RIGHT_BRACE = tuple(KIND_MODULE_DECLARATION, 'module_declaration_right_brace');
const Member MEMBER_MODULE_EXPORTS_EXPORTS = tuple(KIND_MODULE_EXPORTS, 'module_exports_exports');
const Member MEMBER_MODULE_EXPORTS_EXPORTS_KEYWORD = tuple(KIND_MODULE_EXPORTS, 'module_exports_exports_keyword');
const Member MEMBER_MODULE_EXPORTS_LEFT_BRACE = tuple(KIND_MODULE_EXPORTS, 'module_exports_left_brace');
const Member MEMBER_MODULE_EXPORTS_RIGHT_BRACE = tuple(KIND_MODULE_EXPORTS, 'module_exports_right_brace');
const Member MEMBER_MODULE_IMPORTS_IMPORTS = tuple(KIND_MODULE_IMPORTS, 'module_imports_imports');
const Member MEMBER_MODULE_IMPORTS_IMPORTS_KEYWORD = tuple(KIND_MODULE_IMPORTS, 'module_imports_imports_keyword');
const Member MEMBER_MODULE_IMPORTS_LEFT_BRACE = tuple(KIND_MODULE_IMPORTS, 'module_imports_left_brace');
const Member MEMBER_MODULE_IMPORTS_RIGHT_BRACE = tuple(KIND_MODULE_IMPORTS, 'module_imports_right_brace');
const Member MEMBER_MODULE_MEMBERSHIP_DECLARATION_MODULE_KEYWORD = tuple(KIND_MODULE_MEMBERSHIP_DECLARATION, 'module_membership_declaration_module_keyword');
const Member MEMBER_MODULE_MEMBERSHIP_DECLARATION_NAME = tuple(KIND_MODULE_MEMBERSHIP_DECLARATION, 'module_membership_declaration_name');
const Member MEMBER_MODULE_MEMBERSHIP_DECLARATION_SEMICOLON = tuple(KIND_MODULE_MEMBERSHIP_DECLARATION, 'module_membership_declaration_semicolon');
const Member MEMBER_MODULE_NAME_PARTS = tuple(KIND_MODULE_NAME, 'module_name_parts');
const Member MEMBER_NAMESPACE_BODY = tuple(KIND_NAMESPACE_DECLARATION, 'namespace_body');
const Member MEMBER_NAMESPACE_DECLARATIONS = tuple(KIND_NAMESPACE_BODY, 'namespace_declarations');
const Member MEMBER_NAMESPACE_GROUP_USE_CLAUSES = tuple(KIND_NAMESPACE_GROUP_USE_DECLARATION, 'namespace_group_use_clauses');
const Member MEMBER_NAMESPACE_GROUP_USE_KEYWORD = tuple(KIND_NAMESPACE_GROUP_USE_DECLARATION, 'namespace_group_use_keyword');
const Member MEMBER_NAMESPACE_GROUP_USE_KIND = tuple(KIND_NAMESPACE_GROUP_USE_DECLARATION, 'namespace_group_use_kind');
const Member MEMBER_NAMESPACE_GROUP_USE_LEFT_BRACE = tuple(KIND_NAMESPACE_GROUP_USE_DECLARATION, 'namespace_group_use_left_brace');
const Member MEMBER_NAMESPACE_GROUP_USE_PREFIX = tuple(KIND_NAMESPACE_GROUP_USE_DECLARATION, 'namespace_group_use_prefix');
const Member MEMBER_NAMESPACE_GROUP_USE_RIGHT_BRACE = tuple(KIND_NAMESPACE_GROUP_USE_DECLARATION, 'namespace_group_use_right_brace');
const Member MEMBER_NAMESPACE_GROUP_USE_SEMICOLON = tuple(KIND_NAMESPACE_GROUP_USE_DECLARATION, 'namespace_group_use_semicolon');
const Member MEMBER_NAMESPACE_HEADER = tuple(KIND_NAMESPACE_DECLARATION, 'namespace_header');
const Member MEMBER_NAMESPACE_KEYWORD = tuple(KIND_NAMESPACE_DECLARATION_HEADER, 'namespace_keyword');
const Member MEMBER_NAMESPACE_LEFT_BRACE = tuple(KIND_NAMESPACE_BODY, 'namespace_left_brace');
const Member MEMBER_NAMESPACE_NAME = tuple(KIND_NAMESPACE_DECLARATION_HEADER, 'namespace_name');
const Member MEMBER_NAMESPACE_RIGHT_BRACE = tuple(KIND_NAMESPACE_BODY, 'namespace_right_brace');
const Member MEMBER_NAMESPACE_SEMICOLON = tuple(KIND_NAMESPACE_EMPTY_BODY, 'namespace_semicolon');
const Member MEMBER_NAMESPACE_USE_ALIAS = tuple(KIND_NAMESPACE_USE_CLAUSE, 'namespace_use_alias');
const Member MEMBER_NAMESPACE_USE_AS = tuple(KIND_NAMESPACE_USE_CLAUSE, 'namespace_use_as');
const Member MEMBER_NAMESPACE_USE_CLAUSE_KIND = tuple(KIND_NAMESPACE_USE_CLAUSE, 'namespace_use_clause_kind');
const Member MEMBER_NAMESPACE_USE_CLAUSES = tuple(KIND_NAMESPACE_USE_DECLARATION, 'namespace_use_clauses');
const Member MEMBER_NAMESPACE_USE_KEYWORD = tuple(KIND_NAMESPACE_USE_DECLARATION, 'namespace_use_keyword');
const Member MEMBER_NAMESPACE_USE_KIND = tuple(KIND_NAMESPACE_USE_DECLARATION, 'namespace_use_kind');
const Member MEMBER_NAMESPACE_USE_NAME = tuple(KIND_NAMESPACE_USE_CLAUSE, 'namespace_use_name');
const Member MEMBER_NAMESPACE_USE_SEMICOLON = tuple(KIND_NAMESPACE_USE_DECLARATION, 'namespace_use_semicolon');
const Member MEMBER_NULLABLE_AS_LEFT_OPERAND = tuple(KIND_NULLABLE_AS_EXPRESSION, 'nullable_as_left_operand');
const Member MEMBER_NULLABLE_AS_OPERATOR = tuple(KIND_NULLABLE_AS_EXPRESSION, 'nullable_as_operator');
const Member MEMBER_NULLABLE_AS_RIGHT_OPERAND = tuple(KIND_NULLABLE_AS_EXPRESSION, 'nullable_as_right_operand');
const Member MEMBER_NULLABLE_QUESTION = tuple(KIND_NULLABLE_TYPE_SPECIFIER, 'nullable_question');
const Member MEMBER_NULLABLE_TYPE = tuple(KIND_NULLABLE_TYPE_SPECIFIER, 'nullable_type');
const Member MEMBER_OBJECT_CREATION_NEW_KEYWORD = tuple(KIND_OBJECT_CREATION_EXPRESSION, 'object_creation_new_keyword');
const Member MEMBER_OBJECT_CREATION_OBJECT = tuple(KIND_OBJECT_CREATION_EXPRESSION, 'object_creation_object');
const Member MEMBER_OLD_ATTRIBUTE_SPECIFICATION_ATTRIBUTES = tuple(KIND_OLD_ATTRIBUTE_SPECIFICATION, 'old_attribute_specification_attributes');
const Member MEMBER_OLD_ATTRIBUTE_SPECIFICATION_LEFT_DOUBLE_ANGLE = tuple(KIND_OLD_ATTRIBUTE_SPECIFICATION, 'old_attribute_specification_left_double_angle');
const Member MEMBER_OLD_ATTRIBUTE_SPECIFICATION_RIGHT_DOUBLE_ANGLE = tuple(KIND_OLD_ATTRIBUTE_SPECIFICATION, 'old_attribute_specification_right_double_angle');
const Member MEMBER_PACKAGE_DECLARATION_ATTRIBUTE_SPEC = tuple(KIND_PACKAGE_DECLARATION, 'package_declaration_attribute_spec');
const Member MEMBER_PACKAGE_DECLARATION_INCLUDES = tuple(KIND_PACKAGE_DECLARATION, 'package_declaration_includes');
const Member MEMBER_PACKAGE_DECLARATION_LEFT_BRACE = tuple(KIND_PACKAGE_DECLARATION, 'package_declaration_left_brace');
const Member MEMBER_PACKAGE_DECLARATION_NAME = tuple(KIND_PACKAGE_DECLARATION, 'package_declaration_name');
const Member MEMBER_PACKAGE_DECLARATION_PACKAGE_KEYWORD = tuple(KIND_PACKAGE_DECLARATION, 'package_declaration_package_keyword');
const Member MEMBER_PACKAGE_DECLARATION_RIGHT_BRACE = tuple(KIND_PACKAGE_DECLARATION, 'package_declaration_right_brace');
const Member MEMBER_PACKAGE_DECLARATION_USES = tuple(KIND_PACKAGE_DECLARATION, 'package_declaration_uses');
const Member MEMBER_PACKAGE_INCLUDES_INCLUDE_KEYWORD = tuple(KIND_PACKAGE_INCLUDES, 'package_includes_include_keyword');
const Member MEMBER_PACKAGE_INCLUDES_INCLUDES = tuple(KIND_PACKAGE_INCLUDES, 'package_includes_includes');
const Member MEMBER_PACKAGE_INCLUDES_LEFT_BRACE = tuple(KIND_PACKAGE_INCLUDES, 'package_includes_left_brace');
const Member MEMBER_PACKAGE_INCLUDES_RIGHT_BRACE = tuple(KIND_PACKAGE_INCLUDES, 'package_includes_right_brace');
const Member MEMBER_PACKAGE_USES_LEFT_BRACE = tuple(KIND_PACKAGE_USES, 'package_uses_left_brace');
const Member MEMBER_PACKAGE_USES_RIGHT_BRACE = tuple(KIND_PACKAGE_USES, 'package_uses_right_brace');
const Member MEMBER_PACKAGE_USES_USE_KEYWORD = tuple(KIND_PACKAGE_USES, 'package_uses_use_keyword');
const Member MEMBER_PACKAGE_USES_USES = tuple(KIND_PACKAGE_USES, 'package_uses_uses');
const Member MEMBER_PARAMETER_ATTRIBUTE = tuple(KIND_PARAMETER_DECLARATION, 'parameter_attribute');
const Member MEMBER_PARAMETER_CALL_CONVENTION = tuple(KIND_PARAMETER_DECLARATION, 'parameter_call_convention');
const Member MEMBER_PARAMETER_DEFAULT_VALUE = tuple(KIND_PARAMETER_DECLARATION, 'parameter_default_value');
const Member MEMBER_PARAMETER_NAME = tuple(KIND_PARAMETER_DECLARATION, 'parameter_name');
const Member MEMBER_PARAMETER_READONLY = tuple(KIND_PARAMETER_DECLARATION, 'parameter_readonly');
const Member MEMBER_PARAMETER_TYPE = tuple(KIND_PARAMETER_DECLARATION, 'parameter_type');
const Member MEMBER_PARAMETER_VISIBILITY = tuple(KIND_PARAMETER_DECLARATION, 'parameter_visibility');
const Member MEMBER_PARENTHESIZED_EXPRESSION_EXPRESSION = tuple(KIND_PARENTHESIZED_EXPRESSION, 'parenthesized_expression_expression');
const Member MEMBER_PARENTHESIZED_EXPRESSION_LEFT_PAREN = tuple(KIND_PARENTHESIZED_EXPRESSION, 'parenthesized_expression_left_paren');
const Member MEMBER_PARENTHESIZED_EXPRESSION_RIGHT_PAREN = tuple(KIND_PARENTHESIZED_EXPRESSION, 'parenthesized_expression_right_paren');
const Member MEMBER_PIPE_VARIABLE_EXPRESSION = tuple(KIND_PIPE_VARIABLE, 'pipe_variable_expression');
const Member MEMBER_POSTFIX_UNARY_OPERAND = tuple(KIND_POSTFIX_UNARY_EXPRESSION, 'postfix_unary_operand');
const Member MEMBER_POSTFIX_UNARY_OPERATOR = tuple(KIND_POSTFIX_UNARY_EXPRESSION, 'postfix_unary_operator');
const Member MEMBER_PREFIX_UNARY_OPERAND = tuple(KIND_PREFIX_UNARY_EXPRESSION, 'prefix_unary_operand');
const Member MEMBER_PREFIX_UNARY_OPERATOR = tuple(KIND_PREFIX_UNARY_EXPRESSION, 'prefix_unary_operator');
const Member MEMBER_PREFIXED_CODE_EXPRESSION = tuple(KIND_PREFIXED_CODE_EXPRESSION, 'prefixed_code_expression');
const Member MEMBER_PREFIXED_CODE_LEFT_BACKTICK = tuple(KIND_PREFIXED_CODE_EXPRESSION, 'prefixed_code_left_backtick');
const Member MEMBER_PREFIXED_CODE_PREFIX = tuple(KIND_PREFIXED_CODE_EXPRESSION, 'prefixed_code_prefix');
const Member MEMBER_PREFIXED_CODE_RIGHT_BACKTICK = tuple(KIND_PREFIXED_CODE_EXPRESSION, 'prefixed_code_right_backtick');
const Member MEMBER_PREFIXED_STRING_NAME = tuple(KIND_PREFIXED_STRING, 'prefixed_string_name');
const Member MEMBER_PREFIXED_STRING_STR = tuple(KIND_PREFIXED_STRING, 'prefixed_string_str');
const Member MEMBER_PROPERTY_ATTRIBUTE_SPEC = tuple(KIND_PROPERTY_DECLARATION, 'property_attribute_spec');
const Member MEMBER_PROPERTY_DECLARATORS = tuple(KIND_PROPERTY_DECLARATION, 'property_declarators');
const Member MEMBER_PROPERTY_INITIALIZER = tuple(KIND_PROPERTY_DECLARATOR, 'property_initializer');
const Member MEMBER_PROPERTY_MODIFIERS = tuple(KIND_PROPERTY_DECLARATION, 'property_modifiers');
const Member MEMBER_PROPERTY_NAME = tuple(KIND_PROPERTY_DECLARATOR, 'property_name');
const Member MEMBER_PROPERTY_SEMICOLON = tuple(KIND_PROPERTY_DECLARATION, 'property_semicolon');
const Member MEMBER_PROPERTY_TYPE = tuple(KIND_PROPERTY_DECLARATION, 'property_type');
const Member MEMBER_QUALIFIED_NAME_PARTS = tuple(KIND_QUALIFIED_NAME, 'qualified_name_parts');
const Member MEMBER_RECORD_ATTRIBUTE_SPEC = tuple(KIND_RECORD_DECLARATION, 'record_attribute_spec');
const Member MEMBER_RECORD_CREATION_LEFT_BRACKET = tuple(KIND_RECORD_CREATION_EXPRESSION, 'record_creation_left_bracket');
const Member MEMBER_RECORD_CREATION_MEMBERS = tuple(KIND_RECORD_CREATION_EXPRESSION, 'record_creation_members');
const Member MEMBER_RECORD_CREATION_RIGHT_BRACKET = tuple(KIND_RECORD_CREATION_EXPRESSION, 'record_creation_right_bracket');
const Member MEMBER_RECORD_CREATION_TYPE = tuple(KIND_RECORD_CREATION_EXPRESSION, 'record_creation_type');
const Member MEMBER_RECORD_EXTENDS_KEYWORD = tuple(KIND_RECORD_DECLARATION, 'record_extends_keyword');
const Member MEMBER_RECORD_EXTENDS_OPT = tuple(KIND_RECORD_DECLARATION, 'record_extends_opt');
const Member MEMBER_RECORD_FIELD_INIT = tuple(KIND_RECORD_FIELD, 'record_field_init');
const Member MEMBER_RECORD_FIELD_NAME = tuple(KIND_RECORD_FIELD, 'record_field_name');
const Member MEMBER_RECORD_FIELD_SEMI = tuple(KIND_RECORD_FIELD, 'record_field_semi');
const Member MEMBER_RECORD_FIELD_TYPE = tuple(KIND_RECORD_FIELD, 'record_field_type');
const Member MEMBER_RECORD_FIELDS = tuple(KIND_RECORD_DECLARATION, 'record_fields');
const Member MEMBER_RECORD_KEYWORD = tuple(KIND_RECORD_DECLARATION, 'record_keyword');
const Member MEMBER_RECORD_LEFT_BRACE = tuple(KIND_RECORD_DECLARATION, 'record_left_brace');
const Member MEMBER_RECORD_MODIFIER = tuple(KIND_RECORD_DECLARATION, 'record_modifier');
const Member MEMBER_RECORD_NAME = tuple(KIND_RECORD_DECLARATION, 'record_name');
const Member MEMBER_RECORD_RIGHT_BRACE = tuple(KIND_RECORD_DECLARATION, 'record_right_brace');
const Member MEMBER_REIFIED_TYPE_ARGUMENT_REIFIED = tuple(KIND_REIFIED_TYPE_ARGUMENT, 'reified_type_argument_reified');
const Member MEMBER_REIFIED_TYPE_ARGUMENT_TYPE = tuple(KIND_REIFIED_TYPE_ARGUMENT, 'reified_type_argument_type');
const Member MEMBER_REQUIRE_KEYWORD = tuple(KIND_REQUIRE_CLAUSE, 'require_keyword');
const Member MEMBER_REQUIRE_KIND = tuple(KIND_REQUIRE_CLAUSE, 'require_kind');
const Member MEMBER_REQUIRE_NAME = tuple(KIND_REQUIRE_CLAUSE, 'require_name');
const Member MEMBER_REQUIRE_SEMICOLON = tuple(KIND_REQUIRE_CLAUSE, 'require_semicolon');
const Member MEMBER_RETURN_EXPRESSION = tuple(KIND_RETURN_STATEMENT, 'return_expression');
const Member MEMBER_RETURN_KEYWORD = tuple(KIND_RETURN_STATEMENT, 'return_keyword');
const Member MEMBER_RETURN_SEMICOLON = tuple(KIND_RETURN_STATEMENT, 'return_semicolon');
const Member MEMBER_SAFE_MEMBER_NAME = tuple(KIND_SAFE_MEMBER_SELECTION_EXPRESSION, 'safe_member_name');
const Member MEMBER_SAFE_MEMBER_OBJECT = tuple(KIND_SAFE_MEMBER_SELECTION_EXPRESSION, 'safe_member_object');
const Member MEMBER_SAFE_MEMBER_OPERATOR = tuple(KIND_SAFE_MEMBER_SELECTION_EXPRESSION, 'safe_member_operator');
const Member MEMBER_SCOPE_RESOLUTION_NAME = tuple(KIND_SCOPE_RESOLUTION_EXPRESSION, 'scope_resolution_name');
const Member MEMBER_SCOPE_RESOLUTION_OPERATOR = tuple(KIND_SCOPE_RESOLUTION_EXPRESSION, 'scope_resolution_operator');
const Member MEMBER_SCOPE_RESOLUTION_QUALIFIER = tuple(KIND_SCOPE_RESOLUTION_EXPRESSION, 'scope_resolution_qualifier');
const Member MEMBER_SCRIPT_DECLARATIONS = tuple(KIND_SCRIPT, 'script_declarations');
const Member MEMBER_SHAPE_EXPRESSION_FIELDS = tuple(KIND_SHAPE_EXPRESSION, 'shape_expression_fields');
const Member MEMBER_SHAPE_EXPRESSION_KEYWORD = tuple(KIND_SHAPE_EXPRESSION, 'shape_expression_keyword');
const Member MEMBER_SHAPE_EXPRESSION_LEFT_PAREN = tuple(KIND_SHAPE_EXPRESSION, 'shape_expression_left_paren');
const Member MEMBER_SHAPE_EXPRESSION_RIGHT_PAREN = tuple(KIND_SHAPE_EXPRESSION, 'shape_expression_right_paren');
const Member MEMBER_SHAPE_TYPE_ELLIPSIS = tuple(KIND_SHAPE_TYPE_SPECIFIER, 'shape_type_ellipsis');
const Member MEMBER_SHAPE_TYPE_FIELDS = tuple(KIND_SHAPE_TYPE_SPECIFIER, 'shape_type_fields');
const Member MEMBER_SHAPE_TYPE_KEYWORD = tuple(KIND_SHAPE_TYPE_SPECIFIER, 'shape_type_keyword');
const Member MEMBER_SHAPE_TYPE_LEFT_PAREN = tuple(KIND_SHAPE_TYPE_SPECIFIER, 'shape_type_left_paren');
const Member MEMBER_SHAPE_TYPE_RIGHT_PAREN = tuple(KIND_SHAPE_TYPE_SPECIFIER, 'shape_type_right_paren');
const Member MEMBER_SIMPLE_INITIALIZER_EQUAL = tuple(KIND_SIMPLE_INITIALIZER, 'simple_initializer_equal');
const Member MEMBER_SIMPLE_INITIALIZER_VALUE = tuple(KIND_SIMPLE_INITIALIZER, 'simple_initializer_value');
const Member MEMBER_SIMPLE_TYPE_SPECIFIER = tuple(KIND_SIMPLE_TYPE_SPECIFIER, 'simple_type_specifier');
const Member MEMBER_SOFT_AT = tuple(KIND_SOFT_TYPE_SPECIFIER, 'soft_at');
const Member MEMBER_SOFT_TYPE = tuple(KIND_SOFT_TYPE_SPECIFIER, 'soft_type');
const Member MEMBER_SUBSCRIPT_INDEX = tuple(KIND_SUBSCRIPT_EXPRESSION, 'subscript_index');
const Member MEMBER_SUBSCRIPT_LEFT_BRACKET = tuple(KIND_SUBSCRIPT_EXPRESSION, 'subscript_left_bracket');
const Member MEMBER_SUBSCRIPT_RECEIVER = tuple(KIND_SUBSCRIPT_EXPRESSION, 'subscript_receiver');
const Member MEMBER_SUBSCRIPT_RIGHT_BRACKET = tuple(KIND_SUBSCRIPT_EXPRESSION, 'subscript_right_bracket');
const Member MEMBER_SWITCH_EXPRESSION = tuple(KIND_SWITCH_STATEMENT, 'switch_expression');
const Member MEMBER_SWITCH_KEYWORD = tuple(KIND_SWITCH_STATEMENT, 'switch_keyword');
const Member MEMBER_SWITCH_LEFT_BRACE = tuple(KIND_SWITCH_STATEMENT, 'switch_left_brace');
const Member MEMBER_SWITCH_LEFT_PAREN = tuple(KIND_SWITCH_STATEMENT, 'switch_left_paren');
const Member MEMBER_SWITCH_RIGHT_BRACE = tuple(KIND_SWITCH_STATEMENT, 'switch_right_brace');
const Member MEMBER_SWITCH_RIGHT_PAREN = tuple(KIND_SWITCH_STATEMENT, 'switch_right_paren');
const Member MEMBER_SWITCH_SECTION_FALLTHROUGH = tuple(KIND_SWITCH_SECTION, 'switch_section_fallthrough');
const Member MEMBER_SWITCH_SECTION_LABELS = tuple(KIND_SWITCH_SECTION, 'switch_section_labels');
const Member MEMBER_SWITCH_SECTION_STATEMENTS = tuple(KIND_SWITCH_SECTION, 'switch_section_statements');
const Member MEMBER_SWITCH_SECTIONS = tuple(KIND_SWITCH_STATEMENT, 'switch_sections');
const Member MEMBER_THROW_EXPRESSION = tuple(KIND_THROW_STATEMENT, 'throw_expression');
const Member MEMBER_THROW_KEYWORD = tuple(KIND_THROW_STATEMENT, 'throw_keyword');
const Member MEMBER_THROW_SEMICOLON = tuple(KIND_THROW_STATEMENT, 'throw_semicolon');
const Member MEMBER_TRAIT_USE_ALIAS_ITEM_ALIASED_NAME = tuple(KIND_TRAIT_USE_ALIAS_ITEM, 'trait_use_alias_item_aliased_name');
const Member MEMBER_TRAIT_USE_ALIAS_ITEM_ALIASING_NAME = tuple(KIND_TRAIT_USE_ALIAS_ITEM, 'trait_use_alias_item_aliasing_name');
const Member MEMBER_TRAIT_USE_ALIAS_ITEM_KEYWORD = tuple(KIND_TRAIT_USE_ALIAS_ITEM, 'trait_use_alias_item_keyword');
const Member MEMBER_TRAIT_USE_ALIAS_ITEM_MODIFIERS = tuple(KIND_TRAIT_USE_ALIAS_ITEM, 'trait_use_alias_item_modifiers');
const Member MEMBER_TRAIT_USE_CONFLICT_RESOLUTION_CLAUSES = tuple(KIND_TRAIT_USE_CONFLICT_RESOLUTION, 'trait_use_conflict_resolution_clauses');
const Member MEMBER_TRAIT_USE_CONFLICT_RESOLUTION_KEYWORD = tuple(KIND_TRAIT_USE_CONFLICT_RESOLUTION, 'trait_use_conflict_resolution_keyword');
const Member MEMBER_TRAIT_USE_CONFLICT_RESOLUTION_LEFT_BRACE = tuple(KIND_TRAIT_USE_CONFLICT_RESOLUTION, 'trait_use_conflict_resolution_left_brace');
const Member MEMBER_TRAIT_USE_CONFLICT_RESOLUTION_NAMES = tuple(KIND_TRAIT_USE_CONFLICT_RESOLUTION, 'trait_use_conflict_resolution_names');
const Member MEMBER_TRAIT_USE_CONFLICT_RESOLUTION_RIGHT_BRACE = tuple(KIND_TRAIT_USE_CONFLICT_RESOLUTION, 'trait_use_conflict_resolution_right_brace');
const Member MEMBER_TRAIT_USE_KEYWORD = tuple(KIND_TRAIT_USE, 'trait_use_keyword');
const Member MEMBER_TRAIT_USE_NAMES = tuple(KIND_TRAIT_USE, 'trait_use_names');
const Member MEMBER_TRAIT_USE_PRECEDENCE_ITEM_KEYWORD = tuple(KIND_TRAIT_USE_PRECEDENCE_ITEM, 'trait_use_precedence_item_keyword');
const Member MEMBER_TRAIT_USE_PRECEDENCE_ITEM_NAME = tuple(KIND_TRAIT_USE_PRECEDENCE_ITEM, 'trait_use_precedence_item_name');
const Member MEMBER_TRAIT_USE_PRECEDENCE_ITEM_REMOVED_NAMES = tuple(KIND_TRAIT_USE_PRECEDENCE_ITEM, 'trait_use_precedence_item_removed_names');
const Member MEMBER_TRAIT_USE_SEMICOLON = tuple(KIND_TRAIT_USE, 'trait_use_semicolon');
const Member MEMBER_TRY_CATCH_CLAUSES = tuple(KIND_TRY_STATEMENT, 'try_catch_clauses');
const Member MEMBER_TRY_COMPOUND_STATEMENT = tuple(KIND_TRY_STATEMENT, 'try_compound_statement');
const Member MEMBER_TRY_FINALLY_CLAUSE = tuple(KIND_TRY_STATEMENT, 'try_finally_clause');
const Member MEMBER_TRY_KEYWORD = tuple(KIND_TRY_STATEMENT, 'try_keyword');
const Member MEMBER_TUPLE_EXPRESSION_ITEMS = tuple(KIND_TUPLE_EXPRESSION, 'tuple_expression_items');
const Member MEMBER_TUPLE_EXPRESSION_KEYWORD = tuple(KIND_TUPLE_EXPRESSION, 'tuple_expression_keyword');
const Member MEMBER_TUPLE_EXPRESSION_LEFT_PAREN = tuple(KIND_TUPLE_EXPRESSION, 'tuple_expression_left_paren');
const Member MEMBER_TUPLE_EXPRESSION_RIGHT_PAREN = tuple(KIND_TUPLE_EXPRESSION, 'tuple_expression_right_paren');
const Member MEMBER_TUPLE_LEFT_PAREN = tuple(KIND_TUPLE_TYPE_SPECIFIER, 'tuple_left_paren');
const Member MEMBER_TUPLE_RIGHT_PAREN = tuple(KIND_TUPLE_TYPE_SPECIFIER, 'tuple_right_paren');
const Member MEMBER_TUPLE_TYPE_KEYWORD = tuple(KIND_TUPLE_TYPE_EXPLICIT_SPECIFIER, 'tuple_type_keyword');
const Member MEMBER_TUPLE_TYPE_LEFT_ANGLE = tuple(KIND_TUPLE_TYPE_EXPLICIT_SPECIFIER, 'tuple_type_left_angle');
const Member MEMBER_TUPLE_TYPE_RIGHT_ANGLE = tuple(KIND_TUPLE_TYPE_EXPLICIT_SPECIFIER, 'tuple_type_right_angle');
const Member MEMBER_TUPLE_TYPE_TYPES = tuple(KIND_TUPLE_TYPE_EXPLICIT_SPECIFIER, 'tuple_type_types');
const Member MEMBER_TUPLE_TYPES = tuple(KIND_TUPLE_TYPE_SPECIFIER, 'tuple_types');
const Member MEMBER_TYPE_ARGUMENTS_LEFT_ANGLE = tuple(KIND_TYPE_ARGUMENTS, 'type_arguments_left_angle');
const Member MEMBER_TYPE_ARGUMENTS_RIGHT_ANGLE = tuple(KIND_TYPE_ARGUMENTS, 'type_arguments_right_angle');
const Member MEMBER_TYPE_ARGUMENTS_TYPES = tuple(KIND_TYPE_ARGUMENTS, 'type_arguments_types');
const Member MEMBER_TYPE_ATTRIBUTE_SPEC = tuple(KIND_TYPE_PARAMETER, 'type_attribute_spec');
const Member MEMBER_TYPE_CONST_ATTRIBUTE_SPEC = tuple(KIND_TYPE_CONST_DECLARATION, 'type_const_attribute_spec');
const Member MEMBER_TYPE_CONST_EQUAL = tuple(KIND_TYPE_CONST_DECLARATION, 'type_const_equal');
const Member MEMBER_TYPE_CONST_KEYWORD = tuple(KIND_TYPE_CONST_DECLARATION, 'type_const_keyword');
const Member MEMBER_TYPE_CONST_MODIFIERS = tuple(KIND_TYPE_CONST_DECLARATION, 'type_const_modifiers');
const Member MEMBER_TYPE_CONST_NAME = tuple(KIND_TYPE_CONST_DECLARATION, 'type_const_name');
const Member MEMBER_TYPE_CONST_SEMICOLON = tuple(KIND_TYPE_CONST_DECLARATION, 'type_const_semicolon');
const Member MEMBER_TYPE_CONST_TYPE_CONSTRAINT = tuple(KIND_TYPE_CONST_DECLARATION, 'type_const_type_constraint');
const Member MEMBER_TYPE_CONST_TYPE_CONSTRAINTS = tuple(KIND_TYPE_CONST_DECLARATION, 'type_const_type_constraints');
const Member MEMBER_TYPE_CONST_TYPE_KEYWORD = tuple(KIND_TYPE_CONST_DECLARATION, 'type_const_type_keyword');
const Member MEMBER_TYPE_CONST_TYPE_PARAMETERS = tuple(KIND_TYPE_CONST_DECLARATION, 'type_const_type_parameters');
const Member MEMBER_TYPE_CONST_TYPE_SPECIFIER = tuple(KIND_TYPE_CONST_DECLARATION, 'type_const_type_specifier');
const Member MEMBER_TYPE_CONSTANT_LEFT_TYPE = tuple(KIND_TYPE_CONSTANT, 'type_constant_left_type');
const Member MEMBER_TYPE_CONSTANT_RIGHT_TYPE = tuple(KIND_TYPE_CONSTANT, 'type_constant_right_type');
const Member MEMBER_TYPE_CONSTANT_SEPARATOR = tuple(KIND_TYPE_CONSTANT, 'type_constant_separator');
const Member MEMBER_TYPE_CONSTRAINTS = tuple(KIND_TYPE_PARAMETER, 'type_constraints');
const Member MEMBER_TYPE_IN_REFINEMENT_CONSTRAINTS = tuple(KIND_TYPE_IN_REFINEMENT, 'type_in_refinement_constraints');
const Member MEMBER_TYPE_IN_REFINEMENT_EQUAL = tuple(KIND_TYPE_IN_REFINEMENT, 'type_in_refinement_equal');
const Member MEMBER_TYPE_IN_REFINEMENT_KEYWORD = tuple(KIND_TYPE_IN_REFINEMENT, 'type_in_refinement_keyword');
const Member MEMBER_TYPE_IN_REFINEMENT_NAME = tuple(KIND_TYPE_IN_REFINEMENT, 'type_in_refinement_name');
const Member MEMBER_TYPE_IN_REFINEMENT_TYPE = tuple(KIND_TYPE_IN_REFINEMENT, 'type_in_refinement_type');
const Member MEMBER_TYPE_IN_REFINEMENT_TYPE_PARAMETERS = tuple(KIND_TYPE_IN_REFINEMENT, 'type_in_refinement_type_parameters');
const Member MEMBER_TYPE_NAME = tuple(KIND_TYPE_PARAMETER, 'type_name');
const Member MEMBER_TYPE_PARAM_PARAMS = tuple(KIND_TYPE_PARAMETER, 'type_param_params');
const Member MEMBER_TYPE_PARAMETERS_LEFT_ANGLE = tuple(KIND_TYPE_PARAMETERS, 'type_parameters_left_angle');
const Member MEMBER_TYPE_PARAMETERS_PARAMETERS = tuple(KIND_TYPE_PARAMETERS, 'type_parameters_parameters');
const Member MEMBER_TYPE_PARAMETERS_RIGHT_ANGLE = tuple(KIND_TYPE_PARAMETERS, 'type_parameters_right_angle');
const Member MEMBER_TYPE_REFINEMENT_KEYWORD = tuple(KIND_TYPE_REFINEMENT, 'type_refinement_keyword');
const Member MEMBER_TYPE_REFINEMENT_LEFT_BRACE = tuple(KIND_TYPE_REFINEMENT, 'type_refinement_left_brace');
const Member MEMBER_TYPE_REFINEMENT_MEMBERS = tuple(KIND_TYPE_REFINEMENT, 'type_refinement_members');
const Member MEMBER_TYPE_REFINEMENT_RIGHT_BRACE = tuple(KIND_TYPE_REFINEMENT, 'type_refinement_right_brace');
const Member MEMBER_TYPE_REFINEMENT_TYPE = tuple(KIND_TYPE_REFINEMENT, 'type_refinement_type');
const Member MEMBER_TYPE_REIFIED = tuple(KIND_TYPE_PARAMETER, 'type_reified');
const Member MEMBER_TYPE_VARIANCE = tuple(KIND_TYPE_PARAMETER, 'type_variance');
const Member MEMBER_UNION_LEFT_PAREN = tuple(KIND_UNION_TYPE_SPECIFIER, 'union_left_paren');
const Member MEMBER_UNION_RIGHT_PAREN = tuple(KIND_UNION_TYPE_SPECIFIER, 'union_right_paren');
const Member MEMBER_UNION_TYPES = tuple(KIND_UNION_TYPE_SPECIFIER, 'union_types');
const Member MEMBER_UNSET_KEYWORD = tuple(KIND_UNSET_STATEMENT, 'unset_keyword');
const Member MEMBER_UNSET_LEFT_PAREN = tuple(KIND_UNSET_STATEMENT, 'unset_left_paren');
const Member MEMBER_UNSET_RIGHT_PAREN = tuple(KIND_UNSET_STATEMENT, 'unset_right_paren');
const Member MEMBER_UNSET_SEMICOLON = tuple(KIND_UNSET_STATEMENT, 'unset_semicolon');
const Member MEMBER_UNSET_VARIABLES = tuple(KIND_UNSET_STATEMENT, 'unset_variables');
const Member MEMBER_UPCAST_LEFT_OPERAND = tuple(KIND_UPCAST_EXPRESSION, 'upcast_left_operand');
const Member MEMBER_UPCAST_OPERATOR = tuple(KIND_UPCAST_EXPRESSION, 'upcast_operator');
const Member MEMBER_UPCAST_RIGHT_OPERAND = tuple(KIND_UPCAST_EXPRESSION, 'upcast_right_operand');
const Member MEMBER_USING_BLOCK_AWAIT_KEYWORD = tuple(KIND_USING_STATEMENT_BLOCK_SCOPED, 'using_block_await_keyword');
const Member MEMBER_USING_BLOCK_BODY = tuple(KIND_USING_STATEMENT_BLOCK_SCOPED, 'using_block_body');
const Member MEMBER_USING_BLOCK_EXPRESSIONS = tuple(KIND_USING_STATEMENT_BLOCK_SCOPED, 'using_block_expressions');
const Member MEMBER_USING_BLOCK_LEFT_PAREN = tuple(KIND_USING_STATEMENT_BLOCK_SCOPED, 'using_block_left_paren');
const Member MEMBER_USING_BLOCK_RIGHT_PAREN = tuple(KIND_USING_STATEMENT_BLOCK_SCOPED, 'using_block_right_paren');
const Member MEMBER_USING_BLOCK_USING_KEYWORD = tuple(KIND_USING_STATEMENT_BLOCK_SCOPED, 'using_block_using_keyword');
const Member MEMBER_USING_FUNCTION_AWAIT_KEYWORD = tuple(KIND_USING_STATEMENT_FUNCTION_SCOPED, 'using_function_await_keyword');
const Member MEMBER_USING_FUNCTION_EXPRESSION = tuple(KIND_USING_STATEMENT_FUNCTION_SCOPED, 'using_function_expression');
const Member MEMBER_USING_FUNCTION_SEMICOLON = tuple(KIND_USING_STATEMENT_FUNCTION_SCOPED, 'using_function_semicolon');
const Member MEMBER_USING_FUNCTION_USING_KEYWORD = tuple(KIND_USING_STATEMENT_FUNCTION_SCOPED, 'using_function_using_keyword');
const Member MEMBER_VARIABLE_EXPRESSION = tuple(KIND_VARIABLE_SYNTAX, 'variable_expression');
const Member MEMBER_VARIADIC_PARAMETER_CALL_CONVENTION = tuple(KIND_VARIADIC_PARAMETER, 'variadic_parameter_call_convention');
const Member MEMBER_VARIADIC_PARAMETER_ELLIPSIS = tuple(KIND_VARIADIC_PARAMETER, 'variadic_parameter_ellipsis');
const Member MEMBER_VARIADIC_PARAMETER_TYPE = tuple(KIND_VARIADIC_PARAMETER, 'variadic_parameter_type');
const Member MEMBER_VARRAY_INTRINSIC_EXPLICIT_TYPE = tuple(KIND_VARRAY_INTRINSIC_EXPRESSION, 'varray_intrinsic_explicit_type');
const Member MEMBER_VARRAY_INTRINSIC_KEYWORD = tuple(KIND_VARRAY_INTRINSIC_EXPRESSION, 'varray_intrinsic_keyword');
const Member MEMBER_VARRAY_INTRINSIC_LEFT_BRACKET = tuple(KIND_VARRAY_INTRINSIC_EXPRESSION, 'varray_intrinsic_left_bracket');
const Member MEMBER_VARRAY_INTRINSIC_MEMBERS = tuple(KIND_VARRAY_INTRINSIC_EXPRESSION, 'varray_intrinsic_members');
const Member MEMBER_VARRAY_INTRINSIC_RIGHT_BRACKET = tuple(KIND_VARRAY_INTRINSIC_EXPRESSION, 'varray_intrinsic_right_bracket');
const Member MEMBER_VARRAY_KEYWORD = tuple(KIND_VARRAY_TYPE_SPECIFIER, 'varray_keyword');
const Member MEMBER_VARRAY_LEFT_ANGLE = tuple(KIND_VARRAY_TYPE_SPECIFIER, 'varray_left_angle');
const Member MEMBER_VARRAY_RIGHT_ANGLE = tuple(KIND_VARRAY_TYPE_SPECIFIER, 'varray_right_angle');
const Member MEMBER_VARRAY_TRAILING_COMMA = tuple(KIND_VARRAY_TYPE_SPECIFIER, 'varray_trailing_comma');
const Member MEMBER_VARRAY_TYPE = tuple(KIND_VARRAY_TYPE_SPECIFIER, 'varray_type');
const Member MEMBER_VECTOR_INTRINSIC_EXPLICIT_TYPE = tuple(KIND_VECTOR_INTRINSIC_EXPRESSION, 'vector_intrinsic_explicit_type');
const Member MEMBER_VECTOR_INTRINSIC_KEYWORD = tuple(KIND_VECTOR_INTRINSIC_EXPRESSION, 'vector_intrinsic_keyword');
const Member MEMBER_VECTOR_INTRINSIC_LEFT_BRACKET = tuple(KIND_VECTOR_INTRINSIC_EXPRESSION, 'vector_intrinsic_left_bracket');
const Member MEMBER_VECTOR_INTRINSIC_MEMBERS = tuple(KIND_VECTOR_INTRINSIC_EXPRESSION, 'vector_intrinsic_members');
const Member MEMBER_VECTOR_INTRINSIC_RIGHT_BRACKET = tuple(KIND_VECTOR_INTRINSIC_EXPRESSION, 'vector_intrinsic_right_bracket');
const Member MEMBER_VECTOR_TYPE_KEYWORD = tuple(KIND_VECTOR_TYPE_SPECIFIER, 'vector_type_keyword');
const Member MEMBER_VECTOR_TYPE_LEFT_ANGLE = tuple(KIND_VECTOR_TYPE_SPECIFIER, 'vector_type_left_angle');
const Member MEMBER_VECTOR_TYPE_RIGHT_ANGLE = tuple(KIND_VECTOR_TYPE_SPECIFIER, 'vector_type_right_angle');
const Member MEMBER_VECTOR_TYPE_TRAILING_COMMA = tuple(KIND_VECTOR_TYPE_SPECIFIER, 'vector_type_trailing_comma');
const Member MEMBER_VECTOR_TYPE_TYPE = tuple(KIND_VECTOR_TYPE_SPECIFIER, 'vector_type_type');
const Member MEMBER_WHERE_CLAUSE_CONSTRAINTS = tuple(KIND_WHERE_CLAUSE, 'where_clause_constraints');
const Member MEMBER_WHERE_CLAUSE_KEYWORD = tuple(KIND_WHERE_CLAUSE, 'where_clause_keyword');
const Member MEMBER_WHERE_CONSTRAINT_LEFT_TYPE = tuple(KIND_WHERE_CONSTRAINT, 'where_constraint_left_type');
const Member MEMBER_WHERE_CONSTRAINT_OPERATOR = tuple(KIND_WHERE_CONSTRAINT, 'where_constraint_operator');
const Member MEMBER_WHERE_CONSTRAINT_RIGHT_TYPE = tuple(KIND_WHERE_CONSTRAINT, 'where_constraint_right_type');
const Member MEMBER_WHILE_BODY = tuple(KIND_WHILE_STATEMENT, 'while_body');
const Member MEMBER_WHILE_CONDITION = tuple(KIND_WHILE_STATEMENT, 'while_condition');
const Member MEMBER_WHILE_KEYWORD = tuple(KIND_WHILE_STATEMENT, 'while_keyword');
const Member MEMBER_WHILE_LEFT_PAREN = tuple(KIND_WHILE_STATEMENT, 'while_left_paren');
const Member MEMBER_WHILE_RIGHT_PAREN = tuple(KIND_WHILE_STATEMENT, 'while_right_paren');
const Member MEMBER_XHP_ATTRIBUTE_ATTRIBUTES = tuple(KIND_XHP_CLASS_ATTRIBUTE_DECLARATION, 'xhp_attribute_attributes');
const Member MEMBER_XHP_ATTRIBUTE_DECL_INITIALIZER = tuple(KIND_XHP_CLASS_ATTRIBUTE, 'xhp_attribute_decl_initializer');
const Member MEMBER_XHP_ATTRIBUTE_DECL_NAME = tuple(KIND_XHP_CLASS_ATTRIBUTE, 'xhp_attribute_decl_name');
const Member MEMBER_XHP_ATTRIBUTE_DECL_REQUIRED = tuple(KIND_XHP_CLASS_ATTRIBUTE, 'xhp_attribute_decl_required');
const Member MEMBER_XHP_ATTRIBUTE_DECL_TYPE = tuple(KIND_XHP_CLASS_ATTRIBUTE, 'xhp_attribute_decl_type');
const Member MEMBER_XHP_ATTRIBUTE_KEYWORD = tuple(KIND_XHP_CLASS_ATTRIBUTE_DECLARATION, 'xhp_attribute_keyword');
const Member MEMBER_XHP_ATTRIBUTE_SEMICOLON = tuple(KIND_XHP_CLASS_ATTRIBUTE_DECLARATION, 'xhp_attribute_semicolon');
const Member MEMBER_XHP_BODY = tuple(KIND_XHP_EXPRESSION, 'xhp_body');
const Member MEMBER_XHP_CATEGORY_CATEGORIES = tuple(KIND_XHP_CATEGORY_DECLARATION, 'xhp_category_categories');
const Member MEMBER_XHP_CATEGORY_KEYWORD = tuple(KIND_XHP_CATEGORY_DECLARATION, 'xhp_category_keyword');
const Member MEMBER_XHP_CATEGORY_SEMICOLON = tuple(KIND_XHP_CATEGORY_DECLARATION, 'xhp_category_semicolon');
const Member MEMBER_XHP_CHILDREN_EXPRESSION = tuple(KIND_XHP_CHILDREN_DECLARATION, 'xhp_children_expression');
const Member MEMBER_XHP_CHILDREN_KEYWORD = tuple(KIND_XHP_CHILDREN_DECLARATION, 'xhp_children_keyword');
const Member MEMBER_XHP_CHILDREN_LIST_LEFT_PAREN = tuple(KIND_XHP_CHILDREN_PARENTHESIZED_LIST, 'xhp_children_list_left_paren');
const Member MEMBER_XHP_CHILDREN_LIST_RIGHT_PAREN = tuple(KIND_XHP_CHILDREN_PARENTHESIZED_LIST, 'xhp_children_list_right_paren');
const Member MEMBER_XHP_CHILDREN_LIST_XHP_CHILDREN = tuple(KIND_XHP_CHILDREN_PARENTHESIZED_LIST, 'xhp_children_list_xhp_children');
const Member MEMBER_XHP_CHILDREN_SEMICOLON = tuple(KIND_XHP_CHILDREN_DECLARATION, 'xhp_children_semicolon');
const Member MEMBER_XHP_CLOSE = tuple(KIND_XHP_EXPRESSION, 'xhp_close');
const Member MEMBER_XHP_CLOSE_LEFT_ANGLE = tuple(KIND_XHP_CLOSE, 'xhp_close_left_angle');
const Member MEMBER_XHP_CLOSE_NAME = tuple(KIND_XHP_CLOSE, 'xhp_close_name');
const Member MEMBER_XHP_CLOSE_RIGHT_ANGLE = tuple(KIND_XHP_CLOSE, 'xhp_close_right_angle');
const Member MEMBER_XHP_ENUM_KEYWORD = tuple(KIND_XHP_ENUM_TYPE, 'xhp_enum_keyword');
const Member MEMBER_XHP_ENUM_LEFT_BRACE = tuple(KIND_XHP_ENUM_TYPE, 'xhp_enum_left_brace');
const Member MEMBER_XHP_ENUM_LIKE = tuple(KIND_XHP_ENUM_TYPE, 'xhp_enum_like');
const Member MEMBER_XHP_ENUM_RIGHT_BRACE = tuple(KIND_XHP_ENUM_TYPE, 'xhp_enum_right_brace');
const Member MEMBER_XHP_ENUM_VALUES = tuple(KIND_XHP_ENUM_TYPE, 'xhp_enum_values');
const Member MEMBER_XHP_LATEINIT_AT = tuple(KIND_XHP_LATEINIT, 'xhp_lateinit_at');
const Member MEMBER_XHP_LATEINIT_KEYWORD = tuple(KIND_XHP_LATEINIT, 'xhp_lateinit_keyword');
const Member MEMBER_XHP_OPEN = tuple(KIND_XHP_EXPRESSION, 'xhp_open');
const Member MEMBER_XHP_OPEN_ATTRIBUTES = tuple(KIND_XHP_OPEN, 'xhp_open_attributes');
const Member MEMBER_XHP_OPEN_LEFT_ANGLE = tuple(KIND_XHP_OPEN, 'xhp_open_left_angle');
const Member MEMBER_XHP_OPEN_NAME = tuple(KIND_XHP_OPEN, 'xhp_open_name');
const Member MEMBER_XHP_OPEN_RIGHT_ANGLE = tuple(KIND_XHP_OPEN, 'xhp_open_right_angle');
const Member MEMBER_XHP_REQUIRED_AT = tuple(KIND_XHP_REQUIRED, 'xhp_required_at');
const Member MEMBER_XHP_REQUIRED_KEYWORD = tuple(KIND_XHP_REQUIRED, 'xhp_required_keyword');
const Member MEMBER_XHP_SIMPLE_ATTRIBUTE_EQUAL = tuple(KIND_XHP_SIMPLE_ATTRIBUTE, 'xhp_simple_attribute_equal');
const Member MEMBER_XHP_SIMPLE_ATTRIBUTE_EXPRESSION = tuple(KIND_XHP_SIMPLE_ATTRIBUTE, 'xhp_simple_attribute_expression');
const Member MEMBER_XHP_SIMPLE_ATTRIBUTE_NAME = tuple(KIND_XHP_SIMPLE_ATTRIBUTE, 'xhp_simple_attribute_name');
const Member MEMBER_XHP_SIMPLE_CLASS_ATTRIBUTE_TYPE = tuple(KIND_XHP_SIMPLE_CLASS_ATTRIBUTE, 'xhp_simple_class_attribute_type');
const Member MEMBER_XHP_SPREAD_ATTRIBUTE_EXPRESSION = tuple(KIND_XHP_SPREAD_ATTRIBUTE, 'xhp_spread_attribute_expression');
const Member MEMBER_XHP_SPREAD_ATTRIBUTE_LEFT_BRACE = tuple(KIND_XHP_SPREAD_ATTRIBUTE, 'xhp_spread_attribute_left_brace');
const Member MEMBER_XHP_SPREAD_ATTRIBUTE_RIGHT_BRACE = tuple(KIND_XHP_SPREAD_ATTRIBUTE, 'xhp_spread_attribute_right_brace');
const Member MEMBER_XHP_SPREAD_ATTRIBUTE_SPREAD_OPERATOR = tuple(KIND_XHP_SPREAD_ATTRIBUTE, 'xhp_spread_attribute_spread_operator');
const Member MEMBER_YIELD_BREAK_BREAK = tuple(KIND_YIELD_BREAK_STATEMENT, 'yield_break_break');
const Member MEMBER_YIELD_BREAK_KEYWORD = tuple(KIND_YIELD_BREAK_STATEMENT, 'yield_break_keyword');
const Member MEMBER_YIELD_BREAK_SEMICOLON = tuple(KIND_YIELD_BREAK_STATEMENT, 'yield_break_semicolon');
const Member MEMBER_YIELD_KEYWORD = tuple(KIND_YIELD_EXPRESSION, 'yield_keyword');
const Member MEMBER_YIELD_OPERAND = tuple(KIND_YIELD_EXPRESSION, 'yield_operand');
// #endregion
}
///// src/NodeElaboratedGroup.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
enum NodeElaboratedGroup: int {
  SYNTAX = 0;
  TOKEN = 1;
  TRIVIUM = 2;
  LIST = 3;
  MISSING = 4;
}
}
///// src/NodeGroup.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
enum NodeGroup: int {
  SYNTAX = 0;
  TOKEN = 1;
  TRIVIUM = 2;
}
}
///// src/PhaException.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
use type Exception;

/**
 * The exception thrown for all the known reachable error states.
 * If an other exception is thrown from this library,
 * this is a bug and you may report it as such.
 */
interface PhaException {
  require extends Exception;
  public function getMessage()[]: string;
}
}
///// src/ResolveStrategy.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
enum ResolveStrategy: int {
  /**
   * Look at the casing of a type.
   * camel_case -> assume function
   * SHOUT_CAUSE -> assume const
   * PascalCase -> assume type.
   * `_` -> assume type
   * `__...` -> assume built-in attribute or constant
   */
  JUST_GUESS = 0;
}
}
///// src/_Private/Index.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\{C, Vec};
use namespace HTL\Pha;

final class Index<Tnode as Node, Tkind as Kind> {
  /**
   * @param $nodes are sorted by kind, then sub sorted by source order.
   * @param $ranges values are (start, length).
   *   The order is interned string numeric order, but this is not relied upon.
   */
  public function __construct(
    private ParseContext $ctx,
    private Pha\NodeGroup $group,
    private vec<Tnode> $nodes,
    private dict<InternedString<Tkind>, (int, int)> $ranges,
  )[] {}

  /**
   * The returned nodes are in source order.
   */
  public function getByKind(Tkind $kind)[]: vec<Tnode> {
    switch ($this->group) {
      case Pha\NodeGroup::SYNTAX:
        $interned = Pha\syntax_kind_from_kind($kind)
          |> $this->ctx->getSyntaxKinds()->internOrMax($$);
        break;
      case Pha\NodeGroup::TOKEN:
        $interned = Pha\token_kind_from_kind($kind)
          |> $this->ctx->getTokenKinds()->internOrMax($$);
        break;
      case Pha\NodeGroup::TRIVIUM:
        $interned = Pha\trivium_kind_from_kind($kind)
          |> $this->ctx->getTriviumKinds()->internOrMax($$);
    }

    return idx($this->ranges, $interned)
      |> $$ is null ? vec[] : Vec\slice($this->nodes, $$[0], $$[1]);
  }

  /**
   * Careful, `Tnode_` ought to be `Syntax`, `Token`, or `Trivium`, not /just/
   * `Node`, but there is no way to enforce this.
   * If `Tnode_` is `Syntax`, please exclude the LIST and MISSING nodes.
   * `$group` has to belong together with `Tnode_` and `Tkind_`.
   */
  public static function create<Tnode_ as Node, <<__Explicit>> Tkind_ as Kind>(
    ParseContext $ctx,
    Pha\NodeGroup $group,
    vec<Tnode_> $nodes,
  )[]: Index<Tnode_, Tkind_> {
    if (C\is_empty($nodes)) {
      return new Index<Tnode_, Tkind_>($ctx, $group, vec[], dict[]);
    }

    $sorted = Vec\sort_by($nodes, node_get_index_mask<>);
    $ranges = dict[];
    $last_interned = node_get_interned_kind<Tkind_>(C\firstx($sorted));
    $start_range = 0;

    // This $i is just the loop counter, I need it to outlive the loop.
    // A foreach ($sorted as $i => $node) would be more expressive, but
    // HHClientLinter warns about the shadowing, so a manual `++$i` it is...
    $i = 0;
    foreach ($sorted as $node) {
      $interned = node_get_interned_kind<Tkind_>($node);
      if ($interned !== $last_interned) {
        $ranges[$last_interned] = tuple($start_range, $i - $start_range);
        $start_range = $i;
        $last_interned = $interned;
      }
      ++$i;
    }

    $ranges[$last_interned] = tuple($start_range, $i - $start_range + 1);

    return new Index<Tnode_, Tkind_>($ctx, $group, $sorted, $ranges);
  }
}
}
///// src/_Private/InternedString.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
newtype InternedString<+T> as arraykey = int;

function interned_string_from_int<<<__Explicit>> T>(
  int $int,
)[]: InternedString<T> {
  return $int;
}

function interned_string_recast_t<<<__Explicit>> T>(
  InternedString<mixed> $interned_string,
)[]: InternedString<T> {
  return $interned_string;
}

function interned_string_to_int(InternedString<mixed> $interned_string)[]: int {
  return $interned_string;
}
}
///// src/_Private/InternedStringStorage.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\{C, Dict};

final class InternedStringStorage<T as Kind> {
  private vec<T> $items;
  private dict<T, int> $flipped;
  private int $size;

  /**
   * @param $items is keyed by interned string (0..n-1).
   */
  public function __construct(
    private keyset<T> $asKeyset,
    private (function(string)[]: T) $castFunc,
  )[] {
    $this->items = vec($this->asKeyset);
    $this->flipped = Dict\flip($this->items);
    $this->size = C\count($this->items);
  }

  public function asKeyset()[]: keyset<T> {
    return $this->asKeyset;
  }

  public function asVec()[]: vec<string> {
    return $this->items;
  }

  public function fromInterned(InternedString<T> $interned)[]: T {
    return
      $this->items[interned_string_to_int($interned)] |> ($this->castFunc)($$);
  }

  public function intern(T $string)[]: InternedString<T> {
    return interned_string_from_int<T>($this->flipped[$string]);
  }

  public function internOrMax(T $string)[]: InternedString<T> {
    return interned_string_from_int<T>(
      idx($this->flipped, $string, MAX_INTERNED_STRING),
    );
  }

  public function isOfSameSize(keyset<string> $new_names)[]: bool {
    return $this->size === C\count($new_names);
  }
}
}
///// src/_Private/ParseContext.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HTL\Pha;

final class ParseContext {
  public function __construct(
    private Structs $structs,
    private InternedStringStorage<SyntaxKind> $syntaxKinds,
    private InternedStringStorage<TokenKind> $tokenKinds,
    private InternedStringStorage<TriviumKind> $triviumKinds,
  )[] {}

  public function getStructs()[]: Structs {
    return $this->structs;
  }

  public function getSyntaxKinds()[]: InternedStringStorage<SyntaxKind> {
    return $this->syntaxKinds;
  }

  public function getTokenKinds()[]: InternedStringStorage<TokenKind> {
    return $this->tokenKinds;
  }

  public function getTriviumKinds()[]: InternedStringStorage<TriviumKind> {
    return $this->triviumKinds;
  }

  public function upgradeIfNeeded(
    dict<SyntaxKind, vec<Member>> $new_member_names,
    keyset<TokenKind> $new_token_kinds,
    keyset<TriviumKind> $new_trivium_kinds,
  )[]: ParseContext {
    $structs = $this->structs;
    $syntax_kinds = $this->syntaxKinds;
    $token_kinds = $this->tokenKinds;
    $trivium_kinds = $this->triviumKinds;

    $upgrade_needed = false;

    if (!$structs->isOfSameSize($new_member_names)) {
      $upgrade_needed = true;
      $structs = new Structs($new_member_names);
      $syntax_kinds = $structs->asInternedStrings();
    }

    if (!$token_kinds->isOfSameSize($new_token_kinds)) {
      $upgrade_needed = true;
      $token_kinds = new InternedStringStorage<TokenKind>(
        $new_token_kinds,
        Pha\token_kind_from_string<>,
      );
    }

    if (!$trivium_kinds->isOfSameSize($new_trivium_kinds)) {
      $upgrade_needed = true;
      $trivium_kinds = new InternedStringStorage<TriviumKind>(
        $new_trivium_kinds,
        Pha\trivium_kind_from_string<>,
      );
    }

    return $upgrade_needed
      ? new ParseContext($structs, $syntax_kinds, $token_kinds, $trivium_kinds)
      : $this;
  }

  // #region Materialization
  const string VERSION = 'VERSION';
  const string STRUCTS = 'STRUCTS';
  const string SYNTAX_KINDS = 'SYNTAX_KINDS';
  const string TOKEN_KINDS = 'TOKEN_KINDS';
  const string TRIVIUM_KINDS = 'TRIVIUM_KINDS';

  // Memoize because this value can be shared across many scripts.
  <<__Memoize>>
  public function getMaterializationHash()[]: string {
    return $this->dematerialize()
      |> \fb_compact_serialize($$)
      |> \sha1($$, true);
  }

  // Memoize because this value can be shared across many scripts.
  <<__Memoize>>
  public function dematerialize()[]: dict<arraykey, mixed> {
    return dict[
      static::VERSION => 1,
      static::STRUCTS => $this->structs->dematerialize(),
      static::SYNTAX_KINDS => $this->syntaxKinds->asVec(),
      static::TOKEN_KINDS => $this->tokenKinds->asVec(),
      static::TRIVIUM_KINDS => $this->triviumKinds->asVec(),
    ];
  }

  public static function materialize(dict<arraykey, mixed> $raw)[]: this {
    $version = idx($raw, static::VERSION, -1);
    enforce(
      $version === 1,
      'Could not materialize this Context, '.
      'it was dematerialized with a later version of this library.',
    );

    try {
      return new static(
        $raw[static::STRUCTS] |> Structs::materialize($$ as dict<_, _>),
        $raw[static::SYNTAX_KINDS]
          |> as_vec_of_syntax_kind($$)
          |> keyset($$)
          |> new InternedStringStorage($$, Pha\syntax_kind_from_string<>),
        $raw[static::TOKEN_KINDS]
          |> as_vec_of_token_kind($$)
          |> keyset($$)
          |> new InternedStringStorage($$, Pha\token_kind_from_string<>),
        $raw[static::TRIVIUM_KINDS]
          |> as_vec_of_trivium_kind($$)
          |> keyset($$)
          |> new InternedStringStorage($$, Pha\trivium_kind_from_string<>),
      );
    } catch (\Exception $e) {
      throw
        new PhaException('Could not materialize Context.', $e->getCode(), $e);
    }
  }
  // #endregion
}
}
///// src/_Private/Structs.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\{C, Dict, Keyset, Vec};
use namespace HTL\Pha;

final class Structs {
  private int $size;
  public function __construct(
    private dict<SyntaxKind, vec<Member>> $rawMembers,
  )[] {
    $this->size = C\count($rawMembers);
  }

  public function asInternedStrings()[]: InternedStringStorage<SyntaxKind> {
    return new InternedStringStorage<SyntaxKind>(
      Keyset\keys($this->rawMembers),
      Pha\syntax_kind_from_string<>,
    );
  }

  public function getRaw()[]: dict<SyntaxKind, vec<Member>> {
    return $this->rawMembers;
  }

  public function isOfSameSize(dict<string, vec<Member>> $new_members)[]: bool {
    return $this->size === C\count($new_members);
  }

  //#region Materialization
  const string VERSION = 'VERSION';
  const string MEMBERS = 'MEMBERS';

  public function dematerialize()[]: dict<arraykey, mixed> {
    return dict[
      static::VERSION => 1,
      static::MEMBERS => Vec\flatten($this->rawMembers),
    ];
  }

  public static function materialize(dict<arraykey, mixed> $raw)[]: this {
    enforce(
      idx($raw, static::VERSION) === 1,
      'Could not materialize these Structs, '.
      'they were dematerialized with a later version of this library.',
    );

    return $raw[static::MEMBERS]
      |> as_vec_of_member($$)
      |> Dict\group_by($$, Pha\member_get_syntax_kind<>)
      |> new static($$);
  }
  //#endregion
}
}
///// src/_Private/TranslationUnit.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\{Str, Vec};

final class TranslationUnit {
  const SOME_LARGE_JUMP = 64;

  private vec<SourceByteOffset> $lineBreaks;
  /**
   * @param $sourceOrder is keyed by NodeId (0..n-1).
   * @param $siblings is keyed by SiblingId (0..n-1).
   * @param $listSizes only contains the sizes of lists 255 and above.
   */
  public function __construct(
    private vec<Node> $sourceOrder,
    private vec<Node> $siblings,
    private dict<NodeId, int> $listSizes,
    private string $sourceText,
    private ParseContext $ctx,
  )[] {
    $line_breaks = vec[source_byte_offset_from_int(0)];

    $byte = 0;
    foreach (Str\split($sourceText, "\n") as $line) {
      $byte += Str\length($line) + 1;
      $line_breaks[] = source_byte_offset_from_int($byte);
    }

    $this->lineBreaks = $line_breaks;
  }

  public function cutSourceOrder(
    NodeId $from,
    NodeId $to_exclusive,
  )[]: vec<Node> {
    $from = node_id_to_int($from);
    $to_exclusive = node_id_to_int($to_exclusive);
    return Vec\slice($this->sourceOrder, $from, $to_exclusive - $from);
  }

  public function cutSourceRange(SourceRange $range)[]: string {
    list($from, $to_exclusive) = source_range_reveal($range);
    $from = source_byte_offset_to_int($from);
    $to_exclusive =
      $to_exclusive is null ? null : source_byte_offset_to_int($to_exclusive);
    return $to_exclusive is null
      ? Str\slice($this->sourceText, $from)
      : Str\slice($this->sourceText, $from, $to_exclusive - $from);
  }

  public function debugDumpHex()[]: string {
    $out = "SOURCE ORDER:\n";

    $dump_node = $node ==> Str\format(
      '%x|%02x|%05x|%05x|%05x',
      node_get_field_0($node) & 0b11,
      node_get_field_1($node),
      node_get_field_2($node),
      node_get_field_3($node),
      node_get_field_4($node),
    );

    foreach ($this->sourceOrder as $node) {
      $out .= '  '.$dump_node($node)."\n";
    }

    $out .= "SIBLINGS:\n";
    foreach ($this->siblings as $node) {
      $out .= '  '.$dump_node($node)."\n";
    }

    $out .= "SOURCE TEXT:\n";
    $out .= $this->sourceText;

    return $out;
  }

  public function getLineBreaks()[]: vec<SourceByteOffset> {
    return $this->lineBreaks;
  }

  public function getNodeById(NodeId $node_id)[]: NillableNode {
    return idx($this->sourceOrder, node_id_to_int($node_id), NIL);
  }

  public function getNodeByIdx(NodeId $node_id)[]: Node {
    return $this->sourceOrder[node_id_to_int($node_id)];
  }

  public function getNodeBySiblingId(SiblingId $sibling_id)[]: NillableNode {
    return idx($this->siblings, sibling_id_to_int($sibling_id), NIL);
  }

  public function getNodeBySiblingIdx(SiblingId $sibling_id)[]: Node {
    return $this->siblings[sibling_id_to_int($sibling_id)];
  }

  public function getParseContext()[]: ParseContext {
    return $this->ctx;
  }

  public function getSourceOrder()[]: vec<Node> {
    return $this->sourceOrder;
  }

  /**
   * Careful, if `$node` is not a `LIST` or `MISSING`, you'll get junk.
   */
  public function listGetSize(Syntax $syntax)[]: int {
    $stored_length = node_get_field_1($syntax);
    return $stored_length < FIELD_1_MASK
      ? $stored_length
      : $this->listSizes[node_get_id($syntax)];
  }

  public function sliceSiblings(SiblingId $start, int $length)[]: vec<Node> {
    return Vec\slice($this->siblings, sibling_id_to_int($start), $length);
  }

  // #region Materialization
  const string VERSION = 'VERSION';
  const string SOURCE_ORDER = 'SOURCE_ORDER';
  const string SIBLINGS = 'SIBLINGS';
  const string LIST_SIZES = 'LIST_SIZES';
  const string SOURCE_TEXT = 'SOURCE_TEXT';
  const string CONTEXT_ID = 'CONTEXT_ID';

  public function dematerialize()[]: ReadyToSerializeScript {
    return shape(
      'script' => dict[
        'VERSION' => 1,
        'SOURCE_ORDER' => $this->sourceOrder,
        'SIBLINGS' => $this->siblings,
        'LIST_SIZES' => $this->listSizes,
        'SOURCE_TEXT' => $this->sourceText,
        'CONTEXT_ID' => $this->ctx->getMaterializationHash(),
      ],
      'context' => $this->ctx->dematerialize(),
      'context_hash' => $this->ctx->getMaterializationHash(),
    );
  }

  public static function materialize(
    dict<arraykey, mixed> $raw,
    ParseContext $ctx,
  )[]: TranslationUnit {
    enforce(
      idx($raw, static::VERSION) === 1,
      'Could not materialize this Script, '.
      'it was dematerialized with a different version of this library.',
    );
    enforce(
      $ctx->getMaterializationHash() === $raw[static::CONTEXT_ID],
      'The Context and the Script do not belong together.',
    );

    try {
      return new static(
        $raw['SOURCE_ORDER'] |> as_vec_of_node($$),
        $raw['SIBLINGS'] |> as_vec_of_node($$),
        $raw['LIST_SIZES'] |> as_dict_of_node_id_to_int($$),
        $raw['SOURCE_TEXT'] as string,
        $ctx,
      );
    } catch (\Exception $e) {
      throw new PhaException(
        'Failed to materialize this Script.',
        $e->getCode(),
        $e,
      );
    }
  }
}
}
///// src/_Private/aliasses.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HTL\Pha;

type Kind = Pha\Kind;
type Member = Pha\Member;
type TokenKind = Pha\TokenKind;
type TriviumKind = Pha\TriviumKind;
type SyntaxKind = Pha\SyntaxKind;
}
///// src/_Private/change_array_kinds_for_hhvm_4_102.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
/**
 * Pha is best enjoyed on hhvm 4.103+ or with `hhvm.hack_arr_dv_arrs=1`.
 * If you are using an hhvm version with darray as a distinct type,
 * you may also use this alternative implementation of parse:
 * `HH\ffp_parse_string_native(...) |> \json_decode($$, true, 512, \JSON_FB_HACK_ARRAYS)`
 * If you don't do this, you'll incur an extra runtime cost.
 */
function change_array_kinds_for_hhvm_4_102(
  AnyArray<arraykey, mixed> $value,
)[]: dict<arraykey, mixed> {
  if ($value is dict<_, _>) {
    // We are running on hhvm 4.103+ and we don't need to convert array kinds.
    return $value;
  }

  return to_dict_recursively($value) |> dict($$ as KeyedContainer<_, _>);
}
}
///// src/_Private/enforce.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\Str;
use function vsprintf;

/**
 * Think `invariant(...)`, but for `PhaException` instead.
 * Side note: `invariant()` only evaluates the `$format` and `$args`
 * arguments if `$assertion` is false.
 * If the evaluation is computationally expensive,
 * use `if (!$assertion) { ... }` instead.
 */
function enforce(
  bool $assertion,
  Str\SprintfFormatString $format,
  mixed ...$args
)[]: void {
  if (!$assertion) {
    throw new PhaException(vsprintf($format, $args));
  }
}
}
///// src/_Private/grammatical_nth.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
function grammatical_nth(int $n)[]: string {
  // Can't just use NumberFormatter, because it has no contexts.
  $last_two_digits = $n % 100;

  if (
    $last_two_digits === 11 ||
    $last_two_digits === 12 ||
    $last_two_digits === 13
  ) {
    return $n.'th';
  }

  $last_digit = $n % 10;

  if ($last_digit === 1) {
    return $n.'st';
  } else if ($last_digit === 2) {
    return $n.'nd';
  } else if ($last_digit === 3) {
    return $n.'rd';
  }

  return $n.'th';
}
}
///// src/_Private/implemenation_types/Context.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
newtype Context = ParseContext;

function context_hide(ParseContext $ctx)[]: Context {
  return $ctx;
}

function context_reveal(Context $ctx)[]: ParseContext {
  return $ctx;
}
}
///// src/_Private/implemenation_types/IndexMask.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
newtype IndexMask as arraykey = int;

function index_mask_from_int(int $int)[]: IndexMask {
  return $int;
}

function index_mask_to_int(IndexMask $index_mask)[]: int {
  return $index_mask;
}
}
///// src/_Private/implemenation_types/KindIdentity.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
newtype KindIdentity as arraykey = int;

function kind_identity_from_int(int $int)[]: KindIdentity {
  return $int;
}

function kind_identity_to_int(KindIdentity $kind_identity)[]: int {
  return $kind_identity;
}
}
///// src/_Private/implemenation_types/Node.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\Math;

<<__Sealed(Maybe::class)>>
interface Taggable {}
<<__Sealed(Any::class, SyntaxTag::class, TokenTag::class, TriviumTag::class)>>
interface Maybe<+T as Any> extends Taggable {}
<<__Sealed(SyntaxTag::class, TokenTag::class, TriviumTag::class)>>
interface Any extends Maybe<Any> {}
<<__Sealed(NilTag::class)>>
interface SyntaxTag extends Maybe<SyntaxTag>, Any {}
<<__Sealed(NilTag::class)>>
interface TokenTag extends Maybe<TokenTag>, Any {}
<<__Sealed(NilTag::class)>>
interface TriviumTag extends Maybe<TriviumTag>, Any {}
interface NilTag extends SyntaxTag, TokenTag, TriviumTag {}

newtype Tagged<+T as Taggable> = int;

type Nil = Tagged<Maybe<NilTag>>;
type Node = Tagged<Any>;
type Syntax = Tagged<SyntaxTag>;
type Token = Tagged<TokenTag>;
type Trivium = Tagged<TriviumTag>;
type NillableNode = Tagged<Maybe<Any>>;
type NillableSyntax = Tagged<Maybe<SyntaxTag>>;
type NillableToken = Tagged<Maybe<TokenTag>>;
type NillableTrivium = Tagged<Maybe<TriviumTag>>;

const Nil NIL = 0;
const Syntax SCRIPT_NODE = Math\INT64_MIN;

function cast_away_nil<T as Any>(Tagged<Maybe<T>> $t)[]: Tagged<T> {
  return $t;
}

function node_from_int(int $int)[]: Node {
  return $int;
}

function node_to_int(NillableNode $node)[]: int {
  return $node;
}

function nodes_from_ints(vec<int> $ints)[]: vec<Node> {
  return $ints;
}

function nodes_to_ints(vec<NillableNode> $nodes)[]: vec<int> {
  return $nodes;
}

function syntax_from_int(int $int)[]: Syntax {
  return $int;
}

function syntax_from_node(NillableNode $node)[]: Syntax {
  return $node;
}

function syntaxes_from_nodes(vec<NillableNode> $nodes)[]: vec<Syntax> {
  return $nodes;
}

function token_from_int(int $int)[]: Token {
  return $int;
}

function token_from_node(NillableNode $node)[]: Token {
  return $node;
}

function tokens_from_nodes(vec<NillableNode> $nodes)[]: vec<Token> {
  return $nodes;
}

function trivia_from_nodes(vec<NillableNode> $nodes)[]: vec<Trivium> {
  return $nodes;
}

function trivium_from_int(int $int)[]: Trivium {
  return $int;
}

function trivium_from_node(NillableNode $node)[]: Trivium {
  return $node;
}
}
///// src/_Private/implemenation_types/NodeId.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
newtype NodeId as arraykey = int;

function node_id_add(NodeId $node_id, int $n)[]: NodeId {
  return $node_id + $n;
}

function node_id_diff(NodeId $a, NodeId $b)[]: NodeId {
  invariant(
    $a >= $b,
    '%s expected arguments to be ordered from large to small',
    __FUNCTION__,
  );

  return $a - $b;
}

function node_id_to_int(NodeId $node_id)[]: int {
  return $node_id;
}

function node_id_from_int(int $node_id)[]: NodeId {
  return $node_id;
}
}
///// src/_Private/implemenation_types/ReadyToSerialize.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
/**
 * You are not allowed to observe the `mixed` values, aside from serializing them.
 * I wanted to perform the serialization myself, but `\fb_compact_unserialize()`
 * can not be called from a pure context.
 * This means I am leaving the actual encoding up to you, the caller. :)
 *
 * The serialized 'context' may be the same across some scripts.
 * You'd do well to deduplicate those before storing them.
 * You can use the 'context_hash' for this.
 */
type ReadyToSerializeContext = shape(
  'context' => dict<arraykey, mixed>,
  'context_hash' => string,
);

type ReadyToSerializeScript = shape(
  'script' => dict<arraykey, mixed>,
  'context' => dict<arraykey, mixed>,
  'context_hash' => string,
);
}
///// src/_Private/implemenation_types/Resolver.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
newtype Resolver = NameResolver;

function resolver_hide(NameResolver $resolver)[]: Resolver {
  return $resolver;
}

function resolver_reveal(Resolver $resolver)[]: NameResolver {
  return $resolver;
}
}
///// src/_Private/implemenation_types/Script.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
newtype Script = TranslationUnit;

function translation_unit_hide(TranslationUnit $tu)[]: Script {
  return $tu;
}

function translation_unit_reveal(Script $script)[]: TranslationUnit {
  return $script;
}
}
///// src/_Private/implemenation_types/SearchIndex.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
newtype KindIndex<Tnode as Node, Tkind as Kind> = Index<Tnode, Tkind>;

function index_hide<Tnode as Node, Tkind as Kind>(
  Index<Tnode, Tkind> $index,
)[]: KindIndex<Tnode, Tkind> {
  return $index;
}

function index_reveal<Tnode as Node, Tkind as Kind>(
  KindIndex<Tnode, Tkind> $index,
)[]: Index<Tnode, Tkind> {
  return $index;
}
}
///// src/_Private/implemenation_types/SiblingId.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
newtype SiblingId as arraykey = int;

function sibling_id_add(SiblingId $sibling_id, int $n)[]: SiblingId {
  return $sibling_id + $n;
}

function sibling_id_to_int(SiblingId $sibling_id)[]: int {
  return $sibling_id;
}

function sibling_id_from_int(int $int)[]: SiblingId {
  return $int;
}
}
///// src/_Private/implemenation_types/SourceByteOffset.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
newtype SourceByteOffset = int;

function source_byte_offset_from_int(int $int)[]: SourceByteOffset {
  return $int;
}

function source_byte_offset_to_int(SourceByteOffset $offset)[]: int {
  return $offset;
}

function source_byte_offset_is_less_than(
  SourceByteOffset $a,
  SourceByteOffset $b,
)[]: bool {
  return $a < $b;
}

function source_byte_offset_is_less_than_or_equal(
  SourceByteOffset $a,
  SourceByteOffset $b,
)[]: bool {
  return $a < $b;
}
}
///// src/_Private/implemenation_types/SourceRange.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
newtype SourceRange = (SourceByteOffset, ?SourceByteOffset);

function source_range_hide(
  (SourceByteOffset, ?SourceByteOffset) $range,
)[]: SourceRange {
  return $range;
}

function source_range_reveal(
  SourceRange $range,
)[]: (SourceByteOffset, ?SourceByteOffset) {
  return $range;
}
}
///// src/_Private/namespace_resolution/AUTO_IMPORTED_FUNCTIONS.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
// @see https://github.com/facebook/hhvm/blob/09f6283fcdbdac9b4ec19768d809ee7d2012e612/hphp/hack/src/parser/hh_autoimport.ml
const keyset<string> AUTO_IMPORTED_FUNCTIONS = keyset[
  'asio_get_current_context_idx',
  'asio_get_running_in_context',
  'asio_get_running',
  'class_meth',
  'darray',
  'dict',
  // Added by hand
  'die',
  // Added by hand
  'exit',
  'fun',
  'heapgraph_create',
  'heapgraph_dfs_edges',
  'heapgraph_dfs_nodes',
  'heapgraph_edge',
  'heapgraph_foreach_edge',
  'heapgraph_foreach_node',
  'heapgraph_foreach_root',
  'heapgraph_node_in_edges',
  'heapgraph_node_out_edges',
  'heapgraph_node',
  'heapgraph_stats',
  'idx',
  'idx_readonly',
  'inst_meth',
  'invariant_callback_register',
  'invariant_violation',
  'invariant',
  'is_darray',
  'is_dict',
  'is_keyset',
  'is_varray',
  'is_vec',
  'keyset',
  'meth_caller',
  'objprof_get_data',
  'objprof_get_paths',
  'server_warmup_status',
  'thread_mark_stack',
  'thread_memory_stats',
  'type_structure',
  'type_structure_for_alias',
  'varray',
  'vec',
  'xenon_get_data',
];
}
///// src/_Private/namespace_resolution/AUTO_IMPORTED_TYPES.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
// @see https://github.com/facebook/hhvm/blob/09f6283fcdbdac9b4ec19768d809ee7d2012e612/hphp/hack/src/parser/hh_autoimport.ml
const keyset<string> AUTO_IMPORTED_TYPES = keyset[
  'AnyArray',
  'AsyncFunctionWaitHandle',
  'AsyncGenerator',
  'AsyncGeneratorWaitHandle',
  'AsyncIterator',
  'AsyncKeyedIterator',
  'Awaitable',
  'AwaitAllWaitHandle',
  'classname',
  'Collection',
  'ConcurrentWaitHandle',
  'ConditionWaitHandle',
  'Container',
  'darray',
  'dict',
  'ExternalThreadEventWaitHandle',
  'IMemoizeParam',
  'UNSAFESingletonMemoizeParam',
  'ImmMap',
  'ImmSet',
  'ImmVector',
  'InvariantException',
  'Iterable',
  'Iterator',
  'KeyedContainer',
  'KeyedIterable',
  'KeyedIterator',
  'KeyedTraversable',
  'keyset',
  'Map',
  'ObjprofObjectStats',
  'ObjprofPathsStats',
  'ObjprofStringStats',
  'Pair',
  'RescheduleWaitHandle',
  'ResumableWaitHandle',
  'Set',
  'Shapes',
  'SleepWaitHandle',
  'StaticWaitHandle',
  'supportdyn',
  'Traversable',
  'typename',
  'TypeStructure',
  'TypeStructureKind',
  'varray_or_darray',
  'varray',
  'vec_or_dict',
  'vec',
  'Vector',
  'WaitableWaitHandle',
  'XenonSample',
];
}
///// src/_Private/namespace_resolution/NameResolver.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\{C, Str, Vec};
use namespace HTL\Pha;

final class NameResolver {
  private (function(Pha\Node)[]: bool) $parentMakesMeGuessItIsAType;

  public function __construct(
    Pha\Script $script,
    private vec<NamespaceResolution> $namespaceResolution,
    private dict<NodeId, string> $resolvedNames,
    private dict<string, string> $aliasedNamespaces,
    private keyset<string> $autoImportedFunctions,
    private keyset<string> $autoImportedTypes,
  )[] {
    $this->parentMakesMeGuessItIsAType = Pha\create_syntax_matcher(
      $script,
      Pha\KIND_GENERIC_TYPE_SPECIFIER,
      Pha\KIND_SCOPE_RESOLUTION_EXPRESSION,
      Pha\KIND_SIMPLE_TYPE_SPECIFIER,
    );
  }

  public function resolveName(
    Pha\Node $name,
    Pha\Node $parent,
    string $compressed_code,
    Pha\ResolveStrategy $strategy = Pha\ResolveStrategy::JUST_GUESS,
  )[]: (string, NillableSyntax) {
    if (Str\starts_with($compressed_code, '\\')) {
      return tuple(Str\strip_prefix($compressed_code, '\\'), NIL);
    }

    $resolved_name = idx($this->resolvedNames, node_get_id($name));
    if ($resolved_name is nonnull) {
      return tuple($resolved_name, NIL);
    }

    $parts = Str\split($compressed_code, '\\');
    $first_part = $parts[0];
    $suffix = C\count($parts) > 1
      ? Vec\slice($parts, 1) |> Str\join($$, '\\') |> '\\'.$$
      : $first_part;

    switch ($strategy) {
      case Pha\ResolveStrategy::JUST_GUESS:
        if (static::isUnderscoreOrBuiltinAttribute($compressed_code)) {
          return tuple($compressed_code, NIL);
        }
        $kind = ($this->parentMakesMeGuessItIsAType)($parent)
          ? UseKind::TYPE
          : static::guessKind($parts);
    }

    $original_namespace =
      C\findx($this->namespaceResolution, $n ==> $n->isInRange($name));

    for (
      $namespace = $original_namespace;
      $namespace is nonnull;
      $namespace = $namespace->getParent()
    ) {
      $use = idx($namespace->getUses(), $kind, vec[])
        |> C\find($$, $u ==> $u->getLocalName() === $first_part);

      if ($use is nonnull) {
        return tuple(
          $kind === UseKind::NAMESPACE
            ? $use->getPrefix().$suffix
            : $use->getPrefix().$use->getPreAliasName(),
          $use->getClause(),
        );
      }
    }

    if ($kind === UseKind::NAMESPACE) {
      $aliassed_namespace = idx($this->aliasedNamespaces, $first_part);
      if ($aliassed_namespace is nonnull) {
        return tuple($aliassed_namespace.$suffix, NIL);
      }
    }

    if (
      $kind === UseKind::FUNCTION &&
      C\contains_key($this->autoImportedFunctions, $first_part)
    ) {
      return tuple($first_part, NIL);
    }

    if (
      $kind === UseKind::TYPE &&
      C\contains_key($this->autoImportedTypes, $first_part)
    ) {
      return tuple($first_part, NIL);
    }

    return tuple($original_namespace->getName().$compressed_code, NIL);
  }

  private static function guessKind(vec<string> $parts)[]: UseKind {
    if (C\count($parts) !== 1) {
      return UseKind::NAMESPACE;
    }

    $last_part = C\lastx($parts);

    if (Str\lowercase($last_part) === $last_part) {
      return UseKind::FUNCTION;
    }

    if (Str\uppercase($last_part) === $last_part) {
      return UseKind::CONST;
    }

    return UseKind::TYPE;
  }

  private static function isUnderscoreOrBuiltinAttribute(
    string $compressed_code,
  )[]: bool {
    return $compressed_code === '_' ||
      Str\starts_with($compressed_code, '__') &&
        !Str\contains($compressed_code, '\\');
  }
}
}
///// src/_Private/namespace_resolution/NamespaceResolution.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HTL\Pha;

final class NamespaceResolution {
  private NodeId $startsAt;
  private NodeId $endsAt;

  public function __construct(
    Pha\Syntax $starts_at,
    Pha\Node $ends_at,
    private string $name,
    private dict<UseKind, vec<UseInfo>> $uses,
    private ?NamespaceResolution $parent,
  )[] {
    $this->startsAt = node_get_id($starts_at);
    $this->endsAt = node_get_id($ends_at);
  }

  public function getName()[]: string {
    return $this->parent is null
      ? $this->name
      : $this->parent->getName().$this->name;
  }

  public function getParent()[]: ?NamespaceResolution {
    return $this->parent;
  }

  public function getUses()[]: dict<UseKind, vec<UseInfo>> {
    return $this->uses;
  }

  public function isInRange(Pha\Node $node)[]: bool {
    return
      node_is_between_or_at_boundary($node, $this->startsAt, $this->endsAt);
  }
}
}
///// src/_Private/namespace_resolution/UseInfo.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HTL\Pha;

final class UseInfo {
  public function __construct(
    private UseKind $kind,
    private Pha\Syntax $clause,
    private string $prefix,
    private string $localName,
    private string $preAliasName,
  )[] {}

  public function getClause()[]: Pha\Syntax {
    return $this->clause;
  }

  public function getKind()[]: UseKind {
    return $this->kind;
  }

  public function getLocalName()[]: string {
    return $this->localName;
  }

  public function getPreAliasName()[]: string {
    return $this->preAliasName;
  }

  public function getPrefix()[]: string {
    return $this->prefix;
  }
}
}
///// src/_Private/namespace_resolution/UseKind.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
enum UseKind: int {
  CONST = 0;
  FUNCTION = 1;
  NAMESPACE = 2;
  TYPE = 3;
  NONE = 4;
}
}
///// src/_Private/parsing/Intermediate.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HTL\Pha;

final class Intermediate {
  public function __construct(
    private IntermediateGroup $group,
    private int $id,
    private int $parentId,
    private Kind $kind,
    private ?int $textLength = null,
    private ?int $tokenTextTriviumOffset = null,
  )[] {}

  public function getGroup()[]: IntermediateGroup {
    return $this->group;
  }

  public function getGroupName()[]: string {
    return IntermediateGroup::getNames()[$this->group];
  }

  public function getId()[]: int {
    return $this->id;
  }

  public function getParentId()[]: int {
    return $this->parentId;
  }

  public function getSyntaxKind()[]: SyntaxKind {
    invariant(
      $this->group === IntermediateGroup::SYNTAX,
      '%s can not be called on a %s.',
      __FUNCTION__,
      $this->getGroupName(),
    );
    return $this->kind |> Pha\syntax_kind_from_kind($$);
  }

  public function getTokenKind()[]: TokenKind {
    invariant(
      $this->group === IntermediateGroup::TOKEN,
      '%s can not be called on a %s.',
      __FUNCTION__,
      $this->getGroupName(),
    );
    return $this->kind |> Pha\token_kind_from_kind($$);
  }

  public function getTriviumKind()[]: TriviumKind {
    invariant(
      $this->group === IntermediateGroup::TRIVIUM,
      '%s can not be called on a %s.',
      __FUNCTION__,
      $this->getGroupName(),
    );
    return $this->kind |> Pha\trivium_kind_from_kind($$);
  }

  public function getTextLength()[]: ?int {
    return $this->textLength;
  }

  public function getTextLengthx()[]: int {
    invariant(
      $this->textLength is nonnull,
      '%s (%s) has no text',
      $this->kind,
      $this->getGroupName(),
    );
    return $this->textLength;
  }

  public function getTokenTextTriviumOffset()[]: ?int {
    return $this->tokenTextTriviumOffset;
  }

  public function getTokenTextTriviumOffsetx()[]: int {
    invariant(
      $this->tokenTextTriviumOffset is nonnull,
      '%s (%s) has no token text trivium offset',
      $this->kind,
      $this->getGroupName(),
    );
    return $this->tokenTextTriviumOffset;
  }
}
}
///// src/_Private/parsing/IntermediateGroup.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
enum IntermediateGroup: int {
  LIST = 0;
  MISSING = 1;
  SYNTAX = 2;
  TOKEN = 3;
  TRIVIUM = 4;
}
}
///// src/_Private/parsing/Wrapped.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HTL\Pha;

final class Wrapped {
  public function __construct(
    private dict<arraykey, mixed> $item,
    private int $parentId,
  )[] {}

  public function getItem()[]: dict<arraykey, mixed> {
    return $this->item;
  }

  public function createList(int $id)[]: Intermediate {
    return new Intermediate(
      IntermediateGroup::LIST,
      $id,
      $this->parentId,
      Pha\KIND_NODE_LIST,
    );
  }

  public function createMissing(int $id)[]: Intermediate {
    return new Intermediate(
      IntermediateGroup::MISSING,
      $id,
      $this->parentId,
      Pha\KIND_MISSING,
    );
  }

  public function createSyntax(int $id, SyntaxKind $kind)[]: Intermediate {
    return
      new Intermediate(IntermediateGroup::SYNTAX, $id, $this->parentId, $kind);
  }

  public function createToken(
    int $pid,
    TokenKind $kind,
    int $number_of_leading,
  )[]: Intermediate {
    return new Intermediate(
      IntermediateGroup::TOKEN,
      $pid,
      $this->parentId,
      $kind,
      null,
      $number_of_leading + 1,
    );
  }
}
}
///// src/_Private/parsing/create_intermediate_list.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\Vec;

function create_intermediate_list(
  Wrapped $next,
  int $id,
)[]: (Intermediate, vec<Wrapped>) {
  $list = $next->getItem();

  // Could be a dict or a vec, depending on json_decode() options...
  // This is a square bracket array literal in the json,
  // but the default for `\json_decode()` remains to create a dict.
  // If users decode from `HH\ffp_parse_string_native(...)` and json_decode()
  // with `\JSON_DECODE_HACK_ARRAYS`, we'd see vecs here.
  $elements = $list['elements'] as Container<_>;
  $intermediate = $next->createList($id);
  $children = Vec\map($elements, $el ==> new Wrapped($el as dict<_, _>, $id));

  return tuple($intermediate, $children);
}
}
///// src/_Private/parsing/create_intermediate_missing.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
function create_intermediate_missing(Wrapped $next, int $id)[]: Intermediate {
  return $next->createMissing($id);
}
}
///// src/_Private/parsing/create_intermediate_syntax.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HTL\Pha;

function create_intermediate_syntax(
  Wrapped $next,
  int $id,
)[]: (Intermediate, vec<Wrapped>) {
  $syntax = $next->getItem();

  $intermediate = $next->createSyntax(
    $id,
    Pha\syntax_kind_from_string($syntax['kind'] as string),
  );

  $children = vec[];
  foreach ($syntax as $key => $el) {
    if ($key === 'kind') {
      continue;
    }

    $children[] = new Wrapped($el as dict<_, _>, $id);
  }

  return tuple($intermediate, $children);
}
}
///// src/_Private/parsing/create_intermediate_token.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\{C, Str};
use namespace HTL\Pha;

function create_intermediate_token(
  Wrapped $next,
  int $id,
)[]: (Intermediate, vec<Intermediate>) {
  $token = $next->getItem()['token'] as dict<_, _>;
  $leading_raw = $token['leading'] as dict<_, _>;
  $trailing_raw = $token['trailing'] as dict<_, _>;

  $intermediate = $next->createToken(
    $id,
    Pha\token_kind_from_string($token['kind'] as string),
    C\count($leading_raw),
  );

  $count = 1;
  $leading = create_intermediate_trivia($id, $count, $leading_raw);
  $count += C\count($leading_raw);

  $synthetic_token_text_trivium = new Intermediate(
    IntermediateGroup::TRIVIUM,
    $id + $count,
    $id,
    Pha\KIND_TOKEN_TEXT,
    Str\length($token['text'] as string),
  );
  ++$count;

  $trailing = create_intermediate_trivia($id, $count, $trailing_raw);

  $trivia = vec[];

  foreach ($leading as $trivium) {
    $trivia[] = $trivium;
  }

  $trivia[] = $synthetic_token_text_trivium;

  foreach ($trailing as $trivium) {
    $trivia[] = $trivium;
  }

  return tuple($intermediate, $trivia);
}
}
///// src/_Private/parsing/create_intermediate_trivia.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\Str;
use namespace HTL\Pha;

function create_intermediate_trivia(
  int $id,
  int $count,
  dict<arraykey, mixed> $trivia,
)[]: vec<Intermediate> {
  $out = vec[];

  foreach ($trivia as $trivium) {
    $trivium as dict<_, _>;
    $out[] = new Intermediate(
      IntermediateGroup::TRIVIUM,
      $id + $count,
      $id,
      Pha\trivium_kind_from_string($trivium['kind'] as string),
      Str\length($trivium['text'] as string),
    );
    ++$count;
  }

  return $out;
}
}
///// src/_Private/parsing/create_intermediates.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\{C, Vec};
use namespace HTL\Pha;

function create_intermediates(
  dict<arraykey, mixed> $parse_tree,
  inout dict<SyntaxKind, vec<Member>> $known_member_names,
  inout keyset<TokenKind> $known_token_kinds,
  inout keyset<TriviumKind> $known_trivium_kinds,
)[]: vec<Intermediate> {
  $id = 0;
  $completed = vec[];
  $queue = vec[new Wrapped($parse_tree, $id)];
  $queue_ptr = 0;

  do {
    $to_parse = $queue[$queue_ptr];
    switch ($to_parse->getItem()['kind'] as string) {
      case 'token':
        $wrapped_nodes = vec[];
        list($token, $trivia) = create_intermediate_token($to_parse, $id);
        $intermediates = Vec\concat(vec[$token], $trivia);
        $token_kind = $token->getTokenKind();
        if (!C\contains_key($known_token_kinds, $token_kind)) {
          $known_token_kinds[] = $token_kind;
        }
        foreach ($trivia as $trivium) {
          $trivium_kind = $trivium->getTriviumKind();
          if (!C\contains_key($known_trivium_kinds, $trivium_kind)) {
            $known_trivium_kinds[] = $trivium_kind;
          }
        }
        break;
      case 'list':
        list($list, $wrapped_nodes) = create_intermediate_list($to_parse, $id);
        $intermediates = vec[$list];
        break;
      case 'missing':
        $wrapped_nodes = vec[];
        $intermediates = vec[create_intermediate_missing($to_parse, $id)];
        break;
      default /* syntax */:
        list($syntax, $wrapped_nodes) =
          create_intermediate_syntax($to_parse, $id);
        $intermediates = vec[$syntax];
        if (!C\contains_key($known_member_names, $syntax->getSyntaxKind())) {
          $new_names = vec[];

          foreach (Vec\keys($to_parse->getItem()) as $member_name) {
            if ($member_name !== 'kind') {
              $new_names[] = Pha\member_from_tuple(
                tuple($syntax->getSyntaxKind(), $member_name as string),
              );
            }
          }

          $known_member_names[$syntax->getSyntaxKind()] = $new_names;
        }
    }

    ++$queue_ptr;
    $id += C\count($intermediates);

    foreach ($intermediates as $intermediate) {
      $completed[] = $intermediate;
    }

    foreach ($wrapped_nodes as $node) {
      $queue[] = $node;
    }
  } while (C\contains_key($queue, $queue_ptr));

  return Vec\sort_by($completed, $i ==> $i->getId());
}
}
///// src/_Private/parsing/create_node.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\Math;

function create_node(
  Intermediate $node,
  int $source_order_idx,
  int $parent_idx,
  (int, int) $child_range,
  ParseContext $ctx,
  inout int $byte_offset,
)[]: Node {
  // See bin/pseudo-fields.documentation.txt
  switch ($node->getGroup()) {
    case IntermediateGroup::SYNTAX:
      $field_0 = SYNTAX_TAG;
      $field_1 = $ctx->getSyntaxKinds()->intern($node->getSyntaxKind())
        |> interned_string_to_int($$);
      $field_3 = $child_range[0];
      break;
    case IntermediateGroup::TOKEN:
      $field_0 = TOKEN_TAG;
      $field_1 = $ctx->getTokenKinds()->intern($node->getTokenKind())
        |> interned_string_to_int($$);
      $field_3 = $source_order_idx + $node->getTokenTextTriviumOffsetx();
      break;
    case IntermediateGroup::TRIVIUM:
      $field_0 = TRIVIUM_TAG;
      $field_1 = $ctx->getTriviumKinds()->intern($node->getTriviumKind())
        |> interned_string_to_int($$);
      $field_3 = $byte_offset;
      $byte_offset += $node->getTextLengthx();
      break;
    case IntermediateGroup::LIST:
      $field_0 = LIST_OR_MISSING_TAG;
      // + 1, because a range from x to x is of length 1, not 0.
      $field_1 =
        Math\minva(FIELD_1_MASK, $child_range[1] - $child_range[0] + 1);
      $field_3 = $child_range[0];
      break;
    case IntermediateGroup::MISSING:
      $field_0 = LIST_OR_MISSING_TAG;
      $field_1 = 0;
      $field_3 = 0;
  }

  $field_2 = $parent_idx;
  $field_4 = $source_order_idx;

  return node_from_int(
    ($field_0) |
      ($field_1 << 54) |
      ($field_2 << 36) |
      ($field_3 << 18) |
      $field_4,
  );
}
}
///// src/_Private/parsing/create_translation_unit.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\{C, Str, Vec};

function create_translation_unit(
  vec<Intermediate> $intermediates,
  string $source_text,
  ParseContext $ctx,
)[]: TranslationUnit {
  enforce(
    Str\length($source_text) < FIELD_3_MASK,
    'Implementation limit: Source may not exceed %d (0x%x) bytes, got %d.',
    FIELD_3_MASK,
    FIELD_3_MASK,
    Str\length($source_text),
  );

  enforce(
    C\count($intermediates) < FIELD_4_MASK,
    'Implementation limit: Source may not exceed %d (0x%x) nodes, got %d.',
    FIELD_4_MASK,
    FIELD_4_MASK,
    C\count($intermediates),
  );

  list($parent_ranges, $siblings_intermediates) =
    layout_siblings($intermediates);
  $source_order = layout_source_order($intermediates);

  $id_to_source_idx = Vec\fill(C\count($intermediates), 0);
  foreach ($source_order as $source_order_idx => $intermediate) {
    $id_to_source_idx[$intermediate->getId()] = $source_order_idx;
  }

  $byte_offset = 0;
  $nodes = vec[];
  $list_sizes = dict[];
  foreach ($source_order as $source_order_idx => $intermediate) {
    $range = idx($parent_ranges, $intermediate->getId(), tuple(0, 0));
    $nodes[] = create_node(
      $intermediate,
      $source_order_idx,
      $id_to_source_idx[$intermediate->getParentId()],
      $range,
      $ctx,
      inout $byte_offset,
    );

    if ($intermediate->getGroup() === IntermediateGroup::LIST) {
      // + 1, because a range from x to x is of length 1, not 0.
      $size = $range[1] - $range[0] + 1;
      if ($size >= FIELD_1_MASK) {
        $list_sizes[node_id_from_int($source_order_idx)] = $size;
      }
    }
  }

  $siblings = Vec\map(
    $siblings_intermediates,
    $x ==> $nodes[$id_to_source_idx[$x->getId()]],
  );

  return
    new TranslationUnit($nodes, $siblings, $list_sizes, $source_text, $ctx);
}
}
///// src/_Private/parsing/extract_ranges.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\C;

function extract_ranges(
  dict<int, vec<mixed>> $heritage,
)[]: dict<int, (int, int)> {
  $out = dict[];
  $start_range = 0;

  foreach ($heritage as $id => $children) {
    $past_end = $start_range + C\count($children);
    $out[$id] = tuple($start_range, $past_end - 1);
    $start_range = $past_end;
  }

  return $out;
}
}
///// src/_Private/parsing/layout_siblings.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\{Dict, Vec};

/**
 * Get the children of syntax and list nodes.
 * For other nodes, the children are implied:
 *  - Token -> All trivia are sequential
 *  - Trivium / Missing -> Has no children
 *
 * @return (dict<parent_id, (start, end)>, vec<siblings>)
 */
function layout_siblings(
  vec<Intermediate> $intermediates,
)[]: (dict<int, (int, int)>, vec<Intermediate>) {
  $heritage = Vec\filter(
    $intermediates,
    $x ==> (
      $intermediates[$x->getParentId()]->getGroup()
      |> $$ === IntermediateGroup::SYNTAX || $$ === IntermediateGroup::LIST
    ) &&
      $x->getId() !== 0,
  )
    |> Dict\group_by($$, $x ==> $x->getParentId());

  return tuple(extract_ranges($heritage), Vec\flatten($heritage));
}
}
///// src/_Private/parsing/layout_source_order.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\{C, Dict};

function layout_source_order(
  vec<Intermediate> $intermediates,
)[]: vec<Intermediate> {
  $parents_to_children =
    Dict\group_by($intermediates, $x ==> $x->getParentId());
  $out = vec[$intermediates[0], $intermediates[1]];

  // A `vec[]` is used as a `Stack<T>`, since we can't have `[write_props]`.
  // This makes pushing a little cumbersome, see `$stack->push($to_push)`.
  $stack = vec[tuple(1, 0)];
  $stack_ptr = 0;
  $stack_top = 0;

  do {
    list($node_id, $child_number) = $stack[$stack_ptr];
    $children = idx($parents_to_children, $node_id, vec[]);
    ++$stack[$stack_ptr][1];

    if (C\count($children) > $child_number) {
      $child = $children[$child_number];
      $out[] = $child;

      // `$stack->push($to_push)`, but without `[write_props]`
      $to_push = tuple($child->getId(), 0);
      ++$stack_ptr;
      if ($stack_ptr > $stack_top) {
        $stack[] = $to_push;
        ++$stack_top;
      } else {
        $stack[$stack_ptr] = $to_push;
      }
    } else {
      --$stack_ptr;
    }
  } while ($stack_ptr !== -1);

  return $out;
}
}
///// src/_Private/private_node_functions.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\Math;
use namespace HTL\Pha;

const int FIELD_4_SIZE = 18;
const int FIELD_3_SIZE = 18;
const int FIELD_2_SIZE = 18;
const int FIELD_1_SIZE = 8;
const int FIELD_0_SIZE = 2;

const int FIELD_4_OFFSET = 0;
const int FIELD_3_OFFSET = FIELD_4_OFFSET + FIELD_4_SIZE;
const int FIELD_2_OFFSET = FIELD_3_OFFSET + FIELD_3_SIZE;
const int FIELD_1_OFFSET = FIELD_2_OFFSET + FIELD_2_SIZE;
const int FIELD_0_OFFSET = FIELD_1_OFFSET + FIELD_1_SIZE;

const int FIELD_4_MASK = (1 << FIELD_4_SIZE) - 1;
const int FIELD_3_MASK = (1 << FIELD_3_SIZE) - 1;
const int FIELD_2_MASK = (1 << FIELD_2_SIZE) - 1;
const int FIELD_1_MASK = (1 << FIELD_1_SIZE) - 1;
const int FIELD_0_MASK = (1 << FIELD_0_SIZE) - 1;

// This mask is the KindIdentity mask for non-LIST and non-MISSING nodes.
const int FIELD_01_PRE_SHIFT_MASK =
  (FIELD_0_MASK << FIELD_0_OFFSET) | (FIELD_1_MASK << FIELD_1_OFFSET);
// This mask is the IndexMask for non-LIST and non-MISSING nodes.
const int FIELD_14_PRE_SHIFT_MASK =
  (FIELD_1_MASK << FIELD_1_OFFSET) | (FIELD_4_MASK << FIELD_4_OFFSET);

const int SYNTAX_TAG = Math\INT64_MIN;
const int TOKEN_TAG = 1 << 62;
const int TRIVIUM_TAG = 0;
const int LIST_OR_MISSING_TAG = Math\INT64_MIN | (1 << 62);

const int MAX_INTERNED_STRING = FIELD_1_MASK;

/**
 * Careful, if `$kind` is `KIND_NODE_LIST` or `KIND_MISSING`, you'll get a non
 * matching identity.
 */
function create_syntax_identity(
  Script $script,
  SyntaxKind $kind,
)[]: KindIdentity {
  if ($kind === Pha\KIND_NODE_LIST || $kind === Pha\KIND_MISSING) {
    // This is a hack, these nodes don't have an identity.
    // Just return the greatest trivium kind there is.
    // If we ever get to a world with max trivia, consider this
    // a classic case of "This should never happen.".
    return TRIVIUM_TAG | (MAX_INTERNED_STRING << FIELD_1_OFFSET)
      |> kind_identity_from_int($$);
  }

  $ctx = translation_unit_reveal($script)->getParseContext();
  return $ctx->getSyntaxKinds()->internOrMax($kind)
    |> interned_string_to_int($$) << FIELD_1_OFFSET
    |> $$ | SYNTAX_TAG
    |> kind_identity_from_int($$);
}

function create_token_identity(
  Script $script,
  TokenKind $kind,
)[]: KindIdentity {
  $ctx = translation_unit_reveal($script)->getParseContext();
  return $ctx->getTokenKinds()->internOrMax($kind)
    |> interned_string_to_int($$) << FIELD_1_OFFSET
    |> $$ | TOKEN_TAG
    |> kind_identity_from_int($$);
}

function create_trivium_identity(
  Script $script,
  TriviumKind $kind,
)[]: KindIdentity {
  $ctx = translation_unit_reveal($script)->getParseContext();
  return $ctx->getTriviumKinds()->internOrMax($kind)
    |> interned_string_to_int($$) << FIELD_1_OFFSET
    |> $$ | TRIVIUM_TAG
    |> kind_identity_from_int($$);
}

/**
 * Mind the sign extension,
 * so `10`, and `11` will be `...11111110` and `...11111111` respectively.
 */
function node_get_field_0(NillableNode $node)[]: int {
  return node_to_int($node) >> FIELD_0_OFFSET;
}

function node_get_field_1(NillableNode $node)[]: int {
  return node_to_int($node) >> FIELD_1_OFFSET |> $$ & FIELD_1_MASK;
}

function node_get_field_2(NillableNode $node)[]: int {
  return node_to_int($node) >> FIELD_2_OFFSET |> $$ & FIELD_2_MASK;
}

function node_get_field_3(NillableNode $node)[]: int {
  return node_to_int($node) >> FIELD_3_OFFSET |> $$ & FIELD_3_MASK;
}

function node_get_field_4(NillableNode $node)[]: int {
  return node_to_int($node) & FIELD_4_MASK;
}

function node_get_id(Node $node)[]: NodeId {
  return node_get_field_4($node) |> node_id_from_int($$);
}

/**
 * Careful, if `$node` is `LIST` or `MISSING`, you'll get junk.
 */
function node_get_index_mask(Node $node)[]: IndexMask {
  return
    node_to_int($node) & FIELD_14_PRE_SHIFT_MASK |> index_mask_from_int($$);
}

/**
 * Careful, if `$node` is `LIST` or `MISSING`, you'll get junk.
 */
function node_get_interned_kind<<<__Explicit>> T as Kind>(
  Node $node,
)[]: InternedString<T> {
  return node_get_field_1($node) |> interned_string_from_int<T>($$);
}

/**
 * Careful, if `$node` is `LIST` or `MISSING`, you'll get junk.
 */
function node_get_kind_identity(Node $node)[]: KindIdentity {
  return
    node_to_int($node) & FIELD_01_PRE_SHIFT_MASK |> kind_identity_from_int($$);
}

/**
 * This *may* read past the end of the Node to find the very next trivium.
 * This is a very strange function, therefore private.
 */
function node_get_next_trivium(
  Script $script,
  NillableNode $node,
)[]: NillableTrivium {
  if ($node === NIL) {
    return NIL;
  }

  $tu = translation_unit_reveal($script);

  do {
    $node = cast_away_nil($node)
      |> node_get_id($$)
      |> node_id_add($$, 1)
      |> $tu->getNodeById($$);
  } while (!Pha\is_trivium($node) && $node !== NIL);

  return $node === NIL ? NIL : trivium_from_node($node);
}

function node_get_parent_id(Node $node)[]: NodeId {
  return node_get_field_2($node) |> node_id_from_int($$);
}

function node_is_between_or_at_boundary(
  Node $compare,
  NodeId $start,
  NodeId $end,
)[]: bool {
  return node_get_id($compare)
    |> node_id_to_int($$)
    |> $$ >= node_id_to_int($start) && $$ <= node_id_to_int($end);
}

function syntax_get_first_child_sibling_id(Syntax $node)[]: SiblingId {
  return node_get_field_3($node) |> sibling_id_from_int($$);
}

function trivium_get_source_byte_offset(Trivium $trivium)[]: SourceByteOffset {
  return node_get_field_3($trivium) |> source_byte_offset_from_int($$);
}
}
///// src/_Private/three_way_zip.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HH\Lib\{C, Math};

function three_way_zip<T1, T2, T3>(
  Traversable<T1> $first,
  Traversable<T2> $second,
  Traversable<T3> $third,
)[]: vec<(T1, T2, T3)> {
  $one = vec($first);
  $two = vec($second);
  $three = vec($third);

  $result = vec[];
  $lesser_count = Math\minva(C\count($one), C\count($two), C\count($three));

  for ($i = 0; $i < $lesser_count; ++$i) {
    $result[] = tuple($one[$i], $two[$i], $three[$i]);
  }

  return $result;
}
}
///// src/_Private/to_dict_recursively.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
function to_dict_recursively(mixed $maybe_container)[]: mixed {
  if (!$maybe_container is KeyedContainer<_, _>) {
    return $maybe_container;
  }

  $out = dict[];

  foreach ($maybe_container as $key => $value) {
    $out[$key] = to_dict_recursively($value);
  }

  return $out;
}
}
///// src/_Private/type_assert.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HTL\Pha;

// These functions assert to AnyArray<_, _> to survive fb_compact_serialize...

function as_dict_of_node_id_to_int(mixed $raw)[]: dict<NodeId, int> {
  $out = dict[];

  foreach (($raw as AnyArray<_, _>) as $k => $v) {
    $out[node_id_from_int($k as int)] = $v as int;
  }

  return $out;
}

function as_vec_of_member(mixed $raw)[]: vec<Member> {
  $out = vec[];

  foreach (($raw as AnyArray<_, _>) as $v) {
    $v as AnyArray<_, _>;
    $out[] = Pha\member_from_tuple(
      tuple(Pha\syntax_kind_from_string($v[0] as string), $v[1] as string),
    );
  }

  return $out;
}

function as_vec_of_node(mixed $raw)[]: vec<Node> {
  $out = vec[];

  foreach (($raw as AnyArray<_, _>) as $v) {
    $out[] = node_from_int($v as int);
  }

  return $out;
}

function as_vec_of_syntax_kind(mixed $raw)[]: vec<SyntaxKind> {
  $out = vec[];

  foreach (($raw as AnyArray<_, _>) as $v) {
    $out[] = Pha\syntax_kind_from_string($v as string);
  }

  return $out;
}

function as_vec_of_token_kind(mixed $raw)[]: vec<TokenKind> {
  $out = vec[];

  foreach (($raw as AnyArray<_, _>) as $v) {
    $out[] = Pha\token_kind_from_string($v as string);
  }

  return $out;
}

function as_vec_of_trivium_kind(mixed $raw)[]: vec<TriviumKind> {
  $out = vec[];

  foreach (($raw as AnyArray<_, _>) as $v) {
    $out[] = Pha\trivium_kind_from_string($v as string);
  }

  return $out;
}
}
///// src/create_context.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
function create_context()[]: Context {
  return new _Private\ParseContext(
    new _Private\Structs(dict[]),
    new _Private\InternedStringStorage(keyset[], syntax_kind_from_string<>),
    new _Private\InternedStringStorage(keyset[], token_kind_from_string<>),
    new _Private\InternedStringStorage(keyset[], trivium_kind_from_string<>),
  )
    |> _Private\context_hide($$);
}
}
///// src/create_kind_index.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
function create_syntax_kind_index(Script $script)[]: SyntaxIndex {
  $c = _Private\translation_unit_reveal($script)->getParseContext();
  return script_get_syntaxes_without_missing_and_list($script)
    |> _Private\Index::create<Syntax, SyntaxKind>($c, NodeGroup::SYNTAX, $$)
    |> _Private\index_hide($$);
}

function create_token_kind_index(Script $script)[]: TokenIndex {
  $c = _Private\translation_unit_reveal($script)->getParseContext();
  return script_get_tokens($script)
    |> _Private\Index::create<Token, TokenKind>($c, NodeGroup::TOKEN, $$)
    |> _Private\index_hide($$);
}

function create_trivium_kind_index(Script $script)[]: TriviumIndex {
  $c = _Private\translation_unit_reveal($script)->getParseContext();
  return script_get_trivia($script)
    |> _Private\Index::create<Trivium, TriviumKind>($c, NodeGroup::TRIVIUM, $$)
    |> _Private\index_hide($$);
}
}
///// src/create_name_resolver.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
/**
 * @package
 * This code is not strictly a "pure ast operation".
 * If the AST of hhvm changes, you "shouldn't" need to update portable-hack-ast.
 * This is not true for the code in this file. It contains knowledge about hhvm.
 * This code is needed for building complex functionality on top of the AST.
 * It is a concession to usability and should really go in a different package.
 * If you are using this, keep in mind that this code may be given a new home later.
 */

use namespace HH\Lib\{C, Dict, Str, Vec};
use type HTL\Pha\_Private\{NameResolver, NamespaceResolution, UseInfo, UseKind};

/**
 * @param $node must be the qualified name if it is part of a qualified name,
 * else the name token. You can find this using:
 * ```
 * Pha\node_get_ancestors($script, $node) |> C\find($$, $is_qualified_name) ?? $node;
 * ```
 *
 * @param $code_compressed You can get this using:
 * ```
 * Pha\node_get_code_compressed($script, $node);
 * ```
 */
function resolve_name(
  Resolver $resolver,
  Script $script,
  Node $node,
)[]: string {
  return resolve_name_and_use_clause($resolver, $script, $node)[0];
}

function resolve_name_and_use_clause(
  Resolver $resolver,
  Script $script,
  Node $node,
)[]: (string, NillableSyntax) {
  return _Private\resolver_reveal($resolver)->resolveName(
    $node,
    node_get_parent($script, $node),
    node_get_code_compressed($script, $node),
  );
}

/**
 * @param $aliased_namespaces When using the `hhvm.aliased_namespaces` ini +
 * `auto_namespace_map` hhconfig settings, some default namespaces are used.
 * So for example, mapping `Vec` to `HH\Lib\Vec` acts as if every file started
 * with `if (!exists(use clause "Vec")) use namespace HH\Lib\Vec as Vec;`.
 * You can pass the result of `\ini_get("hhvm.aliased_namespaces")` to make
 * `resolve_names` take your pre resolved names into account.
 *
 * @param $auto_imported_functions a list of functions that are available in any
 * hack file without an explicit use clause. If your hhvm version has different
 * auto imported names, and you care, you can pass a different list of names.
 *
 * @param $auto_imported_types a list of types that are available in any
 * hack file without an explicit use clause. If your hhvm version has different
 * auto imported names, and you care, you can pass a different list of names.
 */
function create_name_resolver(
  Script $script,
  SyntaxIndex $syntax_index,
  TokenIndex $token_index,
  dict<string, string> $aliased_namespaces = dict[],
  ?keyset<string> $auto_imported_functions = null,
  ?keyset<string> $auto_imported_types = null,
)[]: Resolver {
  $auto_imported_functions = _Private\AUTO_IMPORTED_FUNCTIONS;
  $auto_imported_types = _Private\AUTO_IMPORTED_TYPES;

  $is_const = create_token_matcher($script, KIND_CONST);
  $is_function = create_token_matcher($script, KIND_FUNCTION);
  $is_function_declaration_header =
    create_syntax_matcher($script, KIND_FUNCTION_DECLARATION_HEADER);
  $is_methodish_declaration =
    create_syntax_matcher($script, KIND_METHODISH_DECLARATION);
  $is_missing = create_syntax_matcher($script, KIND_MISSING);
  $is_namespace = create_token_matcher($script, KIND_NAMESPACE);
  $is_namespace_body = create_syntax_matcher($script, KIND_NAMESPACE_BODY);
  $is_namespace_declaration_header =
    create_syntax_matcher($script, KIND_NAMESPACE_DECLARATION_HEADER);
  $is_namespace_group_use_declaration =
    create_syntax_matcher($script, KIND_NAMESPACE_GROUP_USE_DECLARATION);
  $is_namespace_use_clause =
    create_syntax_matcher($script, KIND_NAMESPACE_USE_CLAUSE);
  $is_namespace_use_or_group_use_declaration = create_syntax_matcher(
    $script,
    KIND_NAMESPACE_USE_DECLARATION,
    KIND_NAMESPACE_GROUP_USE_DECLARATION,
  );
  $is_qualfied_name = create_syntax_matcher($script, KIND_QUALIFIED_NAME);
  $is_type = create_token_matcher($script, KIND_TYPE);

  $get_function_name = create_member_accessor($script, MEMBER_FUNCTION_NAME);
  $get_namespace_body = create_member_accessor($script, MEMBER_NAMESPACE_BODY);
  $get_namespace_declarations =
    create_member_accessor($script, MEMBER_NAMESPACE_DECLARATIONS);
  $get_namespace_group_use_prefix =
    create_member_accessor($script, MEMBER_NAMESPACE_GROUP_USE_PREFIX);
  $get_namespace_header =
    create_member_accessor($script, MEMBER_NAMESPACE_HEADER);
  $get_namespace_name = create_member_accessor($script, MEMBER_NAMESPACE_NAME);
  $get_namespace_use_clauses = create_member_accessor(
    $script,
    MEMBER_NAMESPACE_USE_CLAUSES,
    MEMBER_NAMESPACE_GROUP_USE_CLAUSES,
  );
  $get_namespace_use_alias =
    create_member_accessor($script, MEMBER_NAMESPACE_USE_ALIAS);
  $get_namespace_use_name =
    create_member_accessor($script, MEMBER_NAMESPACE_USE_NAME);
  $get_namespace_use_kind = create_member_accessor(
    $script,
    MEMBER_NAMESPACE_USE_KIND,
    MEMBER_NAMESPACE_GROUP_USE_KIND,
  );

  $namespaces = () ==> {
    $declaration_list =
      node_get_first_childx($script, SCRIPT_NODE) |> as_syntax($$);

    $to_use_infos = $uses ==> Vec\map($uses, $use ==> {
      $use = as_syntax($use);
      $kind = $get_namespace_use_kind($use);
      if ($is_const($kind)) {
        $kind = UseKind::CONST;
      } else if ($is_function($kind)) {
        $kind = UseKind::FUNCTION;
      } else if ($is_namespace($kind)) {
        $kind = UseKind::NAMESPACE;
      } else if ($is_type($kind)) {
        $kind = UseKind::TYPE;
      } else {
        $kind = UseKind::NONE;
      }

      if ($is_namespace_group_use_declaration($use)) {
        $prefix = $get_namespace_group_use_prefix($use)
          |> node_get_code_compressed($script, $$);
      } else {
        $prefix = '';
      }

      $make_use_infos_for_kind = ($kind) ==> $get_namespace_use_clauses($use)
        |> as_syntax($$)
        |> list_get_items_of_children($script, $$)
        |> Vec\map($$, as_syntax<>)
        |> Vec\map(
          $$,
          $clause ==> {
            $use_name_text = $get_namespace_use_name($clause)
              |> node_get_code_compressed($script, $$);

            $last_part = Str\split($use_name_text, '\\') |> C\lastx($$);

            $alias = $get_namespace_use_alias($clause);
            if ($is_missing($alias)) {
              $local_name = $last_part;
            } else {
              $local_name = node_get_code_compressed($script, $alias);
            }

            return new UseInfo(
              $kind,
              $clause,
              $kind === UseKind::NAMESPACE
                ? $prefix.$use_name_text
                : Str\strip_suffix($prefix.$use_name_text, $last_part),
              $local_name,
              $last_part,
            );
          },
        );

      return $kind === UseKind::NONE
        ? Vec\concat(
            vec[$make_use_infos_for_kind(UseKind::NAMESPACE)],
            vec[$make_use_infos_for_kind(UseKind::TYPE)],
          )
          |> Vec\flatten($$)
        : $make_use_infos_for_kind($kind);
    })
      |> Vec\flatten($$)
      |> Dict\group_by($$, $u ==> $u->getKind());

    $namespace_blocks =
      index_get_nodes_by_kind($syntax_index, KIND_NAMESPACE_DECLARATION)
      |> Vec\map($$, $n ==> {
        $scope = $get_namespace_body($n)
          |> $is_namespace_body($$)
            ? as_syntax($$) |> $get_namespace_declarations($$) |> as_syntax($$)
            : $declaration_list;

        $uses = node_get_children($script, $scope)
          |> Vec\filter($$, $is_namespace_use_or_group_use_declaration);

        $name = $get_namespace_header($n)
          |> as_syntax($$)
          |> $get_namespace_name($$)
          |> node_get_code_compressed($script, $$).'\\';

        return shape(
          'namespace' =>
            $is_namespace_body($get_namespace_body($n)) ? $n : SCRIPT_NODE,
          'scope' => $scope,
          'uses' => $to_use_infos($uses),
          'name' => $name,
        );
      });

    if (C\is_empty($namespace_blocks)) {
      $namespace_blocks = vec[
        shape(
          'namespace' => SCRIPT_NODE,
          'scope' => $declaration_list,
          'uses' => $to_use_infos(
            node_get_children($script, $declaration_list)
              |> Vec\filter($$, $is_namespace_use_or_group_use_declaration),
          ),
          'name' => '',
        ),
      ];
    }

    $namespaces = dict[];

    foreach ($namespace_blocks as $block) {
      $parent = C\find(
        node_get_ancestors($script, $block['namespace']),
        $a ==> C\contains_key($namespaces, node_get_source_order($a)),
      )
        |> $$ is null ? null : $namespaces[node_get_source_order($$)];

      $namespaces[node_get_source_order($block['namespace'])] =
        new NamespaceResolution(
          $block['scope'],
          node_get_last_descendant_or_self($script, $block['scope']),
          $block['name'],
          $block['uses'],
          $parent,
        );
    }

    return Vec\reverse($namespaces);
  }();

  $get_closest_namespace = $node ==>
    C\find($namespaces, $n ==> $n->isInRange($node));

  $is_a_parent_that_should_be_resolved_as_is = create_syntax_matcher(
    $script,
    KIND_CONTEXT_CONST_DECLARATION,
    KIND_ENUMERATOR,
    KIND_ENUM_CLASS_ENUMERATOR,
    KIND_MARKUP_SUFFIX,
    KIND_MEMBER_SELECTION_EXPRESSION,
    KIND_NAMESPACE_GROUP_USE_DECLARATION,
    KIND_NAMESPACE_USE_CLAUSE,
    KIND_QUALIFIED_NAME,
    KIND_SAFE_MEMBER_SELECTION_EXPRESSION,
    KIND_SCOPE_RESOLUTION_EXPRESSION,
    KIND_TYPE_PARAMETER,
  );

  $get_a_member_that_should_be_resolved_as_is = create_member_accessor(
    $script,
    MEMBER_CONTEXT_CONST_NAME,
    MEMBER_ENUM_CLASS_ENUMERATOR_NAME,
    MEMBER_ENUMERATOR_NAME,
    MEMBER_MARKUP_SUFFIX_NAME,
    MEMBER_MEMBER_NAME,
    MEMBER_NAMESPACE_GROUP_USE_PREFIX,
    MEMBER_NAMESPACE_USE_ALIAS,
    MEMBER_SAFE_MEMBER_NAME,
    MEMBER_SCOPE_RESOLUTION_NAME,
    MEMBER_TYPE_NAME,
  );

  // Many places where a name token can appear don't need to be resolved,
  // for example `$x->noNeedToResolveThisUseAsIs`.
  $should_be_resolved_as_is = ($grand_parent, $parent, $node) ==>
    $is_a_parent_that_should_be_resolved_as_is($parent) &&
      $get_a_member_that_should_be_resolved_as_is($parent) === $node ||
    // This check needs to be performed separately, because KIND_NAMESPACE_USE_CLAUSE
    // has two members that need to be resolved as-is, alias and name.
    // You therefore can't include this in the member accessor.
    $is_namespace_use_clause($parent) &&
      $get_namespace_use_name($parent) === $node ||
    // Function names are resolved using local rules, but method names are as-is.
    $is_methodish_declaration($grand_parent) &&
      $is_function_declaration_header($parent) &&
      $get_function_name($parent) === $node ||
    // Namespace declarations that aren't namespace blocks don't inherit prefixes.
    $is_namespace_declaration_header($parent) &&
      !$is_namespace_body($get_namespace_body($grand_parent));

  $is_a_parent_that_should_be_resolved_locally = create_syntax_matcher(
    $script,
    KIND_ALIAS_DECLARATION,
    KIND_CLASSISH_DECLARATION,
    KIND_CONTEXT_ALIAS_DECLARATION,
    KIND_CONSTANT_DECLARATOR,
    KIND_ENUM_CLASS_DECLARATION,
    KIND_ENUM_DECLARATION,
    KIND_FUNCTION_DECLARATION_HEADER,
    KIND_NAMESPACE_DECLARATION_HEADER,
    KIND_TYPE_CONST_DECLARATION,
  );

  $get_a_member_that_should_be_resolved_locally = create_member_accessor(
    $script,
    MEMBER_ALIAS_NAME,
    MEMBER_CLASSISH_NAME,
    MEMBER_CTX_ALIAS_NAME,
    MEMBER_CONSTANT_DECLARATOR_NAME,
    MEMBER_ENUM_CLASS_NAME,
    MEMBER_ENUM_NAME,
    MEMBER_FUNCTION_NAME,
    MEMBER_NAMESPACE_NAME,
    MEMBER_TYPE_CONST_NAME,
  );

  // In declarations, the declared name should be resolved in the local namespace.
  // `namespace A; function b(): void {}` is `\A\b`.
  $should_be_resolved_with_local_rules = ($parent, $node) ==>
    $is_a_parent_that_should_be_resolved_locally($parent) &&
    $get_a_member_that_should_be_resolved_locally($parent) === $node;

  $resolve_name = $n ==> {
    $name_text = node_get_code_compressed($script, $n);
    $parent = node_get_parent($script, $n) |> as_syntax($$);
    $grand_parent = syntax_get_parent($script, $parent);

    if ($should_be_resolved_as_is($grand_parent, $parent, $n)) {
      return $name_text;
    }

    if ($should_be_resolved_with_local_rules($parent, $n)) {
      return $get_closest_namespace($n)
        |> $$ is null ? $name_text : $$->getName().$name_text;
    }

    return null;
  };

  return index_get_nodes_by_kind($token_index, KIND_NAME)
    |> Vec\map(
      $$,
      $n ==>
        node_get_ancestors($script, $n) |> C\find($$, $is_qualfied_name) ?? $n,
    )
    |> Vec\unique_by($$, node_get_id<>)
    |> Dict\pull($$, $resolve_name, node_get_id<>)
    |> Dict\filter_nulls($$)
    |> new NameResolver(
      $script,
      $namespaces,
      $$,
      $aliased_namespaces,
      $auto_imported_functions,
      $auto_imported_types,
    )
    |> _Private\resolver_hide($$);
}
}
///// src/create_pragma_map.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
/**
 * @package This code belongs in a tools package somewhere.
 */
use namespace HH\Lib\{C, Str, Vec};

function create_pragma_map(
  Script $script,
  SyntaxIndex $syntax_index,
)[]: PragmaMap {
  $source = node_get_code($script, SCRIPT_NODE);

  $is_expression_statement =
    create_syntax_matcher($script, KIND_EXPRESSION_STATEMENT);

  $get_function_call_arguments =
    create_member_accessor($script, MEMBER_FUNCTION_CALL_ARGUMENT_LIST);
  $get_function_call_receiver =
    create_member_accessor($script, MEMBER_FUNCTION_CALL_RECEIVER);
  $get_constructor_arguments =
    create_member_accessor($script, MEMBER_CONSTRUCTOR_CALL_ARGUMENT_LIST);
  $get_constructor_type =
    create_member_accessor($script, MEMBER_CONSTRUCTOR_CALL_TYPE);
  $get_vec_members =
    create_member_accessor($script, MEMBER_VECTOR_INTRINSIC_MEMBERS);

  $parse_arguments = $node_list ==>
    list_get_items_of_children($script, $node_list)
    |> Vec\map($$, $a ==> node_get_code_compressed($script, $a));

  $parse_attributes = () ==> {
    $pragma_to_scope = $p ==> syntax_get_parent($script, $p)
      |> syntax_get_parent($script, $$)
      |> syntax_get_parent($script, $$)
      |> syntax_get_parent($script, $$)
      |> node_get_source_range($script, $$)
      |> source_range_to_file_and_line_numbers($script, $$);

    $pragmas = index_get_nodes_by_kind($syntax_index, KIND_CONSTRUCTOR_CALL)
      |> Vec\filter(
        $$,
        $c ==> $get_constructor_type($c)
          |> node_get_code_compressed($script, $$) === 'Pragmas',
      );

    $effects = Vec\map(
      $pragmas,
      $p ==> $get_constructor_arguments($p)
        |> as_syntax($$)
        |> list_get_items_of_children($script, $$)
        |> Vec\map(
          $$,
          $vec ==> as_syntax($vec)
            |> $get_vec_members($$)
            |> as_syntax($$)
            |> $parse_arguments($$),
        ),
    );

    $out = vec[];
    foreach ($pragmas as $i => $pragma) {
      $scope = $pragma_to_scope($pragma);
      foreach ($effects[$i] as $effect) {
        $out[] = tuple($pragma, $scope, $effect);
      }
    }

    return $out;
  };

  $parse_directives = () ==> {
    $pragma_to_scope = $p ==> node_get_ancestors($script, $p)
      |> C\find($$, $is_expression_statement) ?? $p
      |> node_get_source_range($script, $$)
      |> source_range_to_file_and_line_numbers($script, $$)
      |> new LineAndColumnNumbers(
        $$->getStartLine(),
        $$->getStartColumn(),
        $$->getEndLine() + 1,
        $$->getEndColumn(),
      );

    $pragmas =
      index_get_nodes_by_kind($syntax_index, KIND_FUNCTION_CALL_EXPRESSION)
      |> Vec\filter(
        $$,
        $f ==> $get_function_call_receiver($f)
          |> node_get_code_compressed($script, $$) === 'pragma',
      );

    $effects = Vec\map(
      $pragmas,
      $p ==> $get_function_call_arguments($p)
        |> as_syntax($$)
        |> $parse_arguments($$),
    );

    return _Private\three_way_zip(
      $pragmas,
      Vec\map($pragmas, $pragma_to_scope),
      $effects,
    );
  };

  $pragma_lines = vec[];

  if (Str\contains($source, 'use type HTL\\Pragma\\Pragmas;')) {
    $pragma_lines = $parse_attributes();
  }

  if (Str\contains($source, 'use function HTL\\Pragma\\pragma;')) {
    $pragma_lines = Vec\concat($pragma_lines, $parse_directives());
  }

  return new PragmaMap($pragma_lines);
}

final class PragmaMap {
  public function __construct(
    private vec<(Syntax, LineAndColumnNumbers, vec<string>)> $pragmas,
  )[] {}

  public function getOverlappingPragmas(
    LineAndColumnNumbers $target,
  )[]: vec<vec<string>> {
    return Vec\filter(
      $this->pragmas,
      $t ==> $target->getEndLine() >= $t[1]->getStartLine() &&
        $target->getStartLine() <= $t[1]->getEndLine(),
    )
      |> Vec\map($$, $t ==> $t[2]);
  }

  public function getAllPragmas(
  )[]: vec<(Syntax, LineAndColumnNumbers, vec<string>)> {
    return $this->pragmas;
  }
}
}
///// src/materialize.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
function dematerialize_context(Context $ctx)[]: ReadyToSerializeContext {
  return _Private\context_reveal($ctx)
    |> shape(
      'context' => $$->dematerialize(),
      'context_hash' => $$->getMaterializationHash(),
    );
}

function dematerialize_script(Script $script)[]: ReadyToSerializeScript {
  return _Private\translation_unit_reveal($script)->dematerialize();
}

function materialize_context(dict<arraykey, mixed> $dematerialized)[]: Context {
  return _Private\ParseContext::materialize($dematerialized)
    |> _Private\context_hide($$);
}

/**
 * If you provide a value that was not returned by `dematerialize_script`,
 * you are invoking undefined behavior.
 */
function materialize_script(
  dict<arraykey, mixed> $dematerialized,
  Context $ctx,
)[]: Script {
  return _Private\context_reveal($ctx)
    |> _Private\TranslationUnit::materialize($dematerialized, $$)
    |> _Private\translation_unit_hide($$);
}
}
///// src/node_functions.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
use namespace HH\Lib\{C, Dict, Math, Str, Vec};

/**
 * @package This file contains all the functions that operate on `Node`.
 * Think of them as methods on the `Node` "class".
 *
 * Some help for searching:
 *  - All functions are in `camel_case()`. `SHOUT_CASE` things are constants.
 *  - Functions that start with `node_` will work on all Nodes,
 *    sometimes even nillable nodes.
 *  - Functions that start with `syntax_`, `token_`, or `trivium_` only work on
 *    syntaxes, tokens, and trivia (or their nillable counterparts) respectively.
 *  - `Node`, `Syntax`, `Token`, and `Trivium` are not `<<__Enforceable>>`.
 *    Replacements are provided in the form of functions.
 *    - `is`: `Pha\is_x()`
 *    - `as`: `Pha\as_x()`
 *    - `?as`: `Pha\as_x_or_nil()` will return `Pha\NIL`, not `null` on failure.
 */

/**
 * @throws Iff $node is NIL.
 */
function as_nonnil<T as _Private\Any>(
  _Private\Tagged<_Private\Maybe<T>> $node,
)[]: _Private\Tagged<T> {
  if ($node === NIL) {
    throw new _Private\PhaException(Str\format('%s got NIL', __FUNCTION__));
  }

  return _Private\cast_away_nil($node);
}

/**
 * @throws Iff $node is not Syntax.
 */
function as_syntax(NillableNode $node)[]: Syntax {
  $ret = as_syntax_or_nil($node);

  if ($ret !== NIL) {
    return _Private\cast_away_nil($ret);
  }

  throw new _Private\PhaException(Str\format(
    '%s expected a Syntax, got %s.',
    __FUNCTION__,
    node_get_group_name($node),
  ));
}

function as_syntax_or_nil(NillableNode $node)[]: NillableSyntax {
  return $node !== NIL &&
    node_get_group(_Private\cast_away_nil($node)) === NodeGroup::SYNTAX
    ? _Private\syntax_from_node($node)
    : NIL;
}

/**
 * @throws Iff $node is not Token.
 */
function as_token(NillableNode $node)[]: Token {
  $ret = as_token_or_nil($node);

  if ($ret !== NIL) {
    return _Private\cast_away_nil($ret);
  }

  throw new _Private\PhaException(Str\format(
    '%s expected a Token, got %s.',
    __FUNCTION__,
    node_get_group_name($node),
  ));
}

function as_token_or_nil(NillableNode $node)[]: NillableToken {
  return $node !== NIL &&
    node_get_group(_Private\cast_away_nil($node)) === NodeGroup::TOKEN
    ? _Private\token_from_node($node)
    : NIL;
}

/**
 * @throws If $node is not Trivium.
 */
function as_trivium(NillableNode $node)[]: Trivium {
  $ret = as_trivium_or_nil($node);

  if ($ret !== NIL) {
    return _Private\cast_away_nil($ret);
  }

  throw new _Private\PhaException(Str\format(
    '%s expected a Trivium, got %s.',
    __FUNCTION__,
    node_get_group_name($node),
  ));
}

function as_trivium_or_nil(NillableNode $node)[]: NillableTrivium {
  return $node !== NIL &&
    node_get_group(_Private\cast_away_nil($node)) === NodeGroup::TRIVIUM
    ? _Private\trivium_from_node($node)
    : NIL;
}

/**
 * This returns an optimized predicate that checks the kind of the node passed.
 * Don't create these matchers in a loop. That defeats the perf benefits.
 * Prefer using matchers over checking the kind if the code becomes easier to read.
 *
 * ```
 * $is_basic_math_operator = create_matcher(
 *   $script,
 *   vec[],
 *   vec[Pha\KIND_PLUS, Pha\KIND_MINUS, Pha\KIND_STAR, Pha\KIND_SLASH],
 *   vec[],
 * );
 *
 * $some_node_or_nil = ...;
 * if ($is_basic_math_operator($some_node_or_nil)) { ... }
 * ```
 */
function create_matcher(
  Script $script,
  vec<SyntaxKind> $syntax_kinds,
  vec<TokenKind> $token_kinds,
  vec<TriviumKind> $trivium_kinds,
)[]: (function(NillableNode)[]: bool) {
  $identities = Vec\concat(
    Vec\map($syntax_kinds, $k ==> _Private\create_syntax_identity($script, $k)),
    Vec\map($token_kinds, $k ==> _Private\create_token_identity($script, $k)),
    Vec\map(
      $trivium_kinds,
      $k ==> _Private\create_trivium_identity($script, $k),
    ),
  )
    |> Vec\unique($$);

  // `-1` is a `false`, since all bits are set, even those outside the mask.
  $id_0 = idx($identities, 0, -1);
  $id_1 = idx($identities, 1, -1);
  $id_2 = idx($identities, 2, -1);
  $id_3 = idx($identities, 3, -1);

  // All arms are equivalent to the `default:` arm,
  // but they don't need to iterate the $identities vec.
  $matcher = () ==> {
    switch (C\count($identities)) {
      case 0:
        return $_ ==> false;
      case 1:
        return $n ==> $n !== NIL &&
          (
            _Private\node_get_kind_identity(_Private\cast_away_nil($n))
            |> $$ === $id_0
          );
      case 2:
      case 3:
      case 4:
        return $n ==> $n !== NIL &&
          (
            _Private\node_get_kind_identity(_Private\cast_away_nil($n))
            |> $$ === $id_0 || $$ === $id_1 || $$ === $id_2 || $$ === $id_3
          );
      default:
        return $n ==> $n !== NIL &&
          (
            _Private\node_get_kind_identity(_Private\cast_away_nil($n))
            |> C\contains($identities, $$)
          );
    }
  }();

  $look_for_list = C\contains($syntax_kinds, KIND_NODE_LIST);
  $look_for_missing = C\contains($syntax_kinds, KIND_MISSING);

  if ($look_for_list || $look_for_missing) {
    return $n ==> {
      if ($n === NIL) {
        return false;
      }

      $n = _Private\cast_away_nil($n);

      switch (node_get_elaborated_group($n)) {
        case NodeElaboratedGroup::LIST:
          return $look_for_list;
        case NodeElaboratedGroup::MISSING:
          return $look_for_missing;
        default:
          return $matcher($n);
      }
    };
  }

  return $matcher;
}

/**
 * A useful utility when dealing with code that intends to be polymorphic over
 * multiple Syntax nodes.
 *
 * ```
 * $get_clauses = create_member_accessor($script, dict[
 *   Pha\KIND_NAMESPACE_USE_DECLARATION => Pha\MEMBER_NAMESPACE_USE_CLAUSES,
 *   Pha\KIND_NAMESPACE_GROUP_USE_DECLARATION => Pha\MEMBER_NAMESPACE_GROUP_USE_CLAUSES,
 * ]);
 *
 * $namespace_use_or_group_use_declaration = ...;
 * $clauses = $get_clauses($namespace_use_or_group_use_declaration);
 * ```
 */
function create_member_accessor(
  Script $script,
  Member ...$accessors
)[]: (function(Syntax)[]: Node) {
  $tu = _Private\translation_unit_reveal($script);
  $structs = $tu->getParseContext()->getStructs();

  $interned = Dict\pull(
    $accessors,
    $member ==> {
      $syntax_kind = member_get_syntax_kind($member);
      $members = idx($structs->getRaw(), $syntax_kind);

      if ($members is null) {
        return null;
      }

      $idx = C\find_key($members, $m ==> $member === $m);

      if ($idx is nonnull) {
        return $idx;
      }

      throw new _Private\PhaException(
        Str\format(
          '%s does not have a member named %s. Only %s does have this member.',
          $syntax_kind,
          member_get_name($member),
          member_get_syntax_kind($member),
        ),
      );
    },
    $member ==>
      _Private\create_syntax_identity($script, member_get_syntax_kind($member)),
  );

  // Optimize for the common case
  if (C\count($interned) === 1) {
    $identity = C\first_keyx($interned);
    $child_number = $interned[$identity];
    return $n ==> {
      if (
        _Private\node_get_kind_identity($n) !== $identity ||
        $child_number is null
      ) {
        throw new _Private\PhaException(Str\format(
          'No syntax accessor defined for %s.',
          node_get_kind($script, $n),
        ));
      }

      return node_get_nth_childx($script, $n, $child_number);
    };
  }

  return $n ==> {
    $idx = idx($interned, _Private\node_get_kind_identity($n));

    if ($idx is null) {
      throw new _Private\PhaException(Str\format(
        'No syntax accessor defined for %s.',
        node_get_kind($script, $n),
      ));
    }

    return node_get_nth_childx($script, $n, $idx);
  };
}

function create_syntax_matcher(
  Script $script,
  SyntaxKind $first,
  SyntaxKind ...$rest
)[]: (function(NillableNode)[]: bool) {
  return create_matcher($script, Vec\concat(vec[$first], $rest), vec[], vec[]);
}

function create_token_matcher(
  Script $script,
  TokenKind $first,
  TokenKind ...$rest
)[]: (function(NillableNode)[]: bool) {
  return create_matcher($script, vec[], Vec\concat(vec[$first], $rest), vec[]);
}

function create_trivium_matcher(
  Script $script,
  TriviumKind $first,
  TriviumKind ...$rest
)[]: (function(NillableNode)[]: bool) {
  return create_matcher($script, vec[], vec[], Vec\concat(vec[$first], $rest));
}

/**
 * @param $index is a `ScriptIndex`, `TokenIndex`, or a `TriviumIndex`.
 * The returned nodes are in source order.
 */
function index_get_nodes_by_kind<Tnode as Node, Tkind as Kind>(
  _Private\KindIndex<Tnode, Tkind> $index,
  Tkind $kind,
)[]: vec<Tnode> {
  return _Private\index_reveal($index)->getByKind($kind);
}

function is_syntax(NillableNode $node)[]: bool {
  if ($node === NIL) {
    return false;
  }

  $node = _Private\cast_away_nil($node);

  switch (node_get_group($node)) {
    case NodeGroup::SYNTAX:
      return true;
    case NodeGroup::TOKEN:
    case NodeGroup::TRIVIUM:
      return false;
  }
}

function is_token(NillableNode $node)[]: bool {
  if ($node === NIL) {
    return false;
  }

  $node = _Private\cast_away_nil($node);

  switch (node_get_group($node)) {
    case NodeGroup::SYNTAX:
      return false;
    case NodeGroup::TOKEN:
      return true;
    case NodeGroup::TRIVIUM:
      return false;
  }
}

function is_trivium(NillableNode $node)[]: bool {
  if ($node === NIL) {
    return false;
  }

  $node = _Private\cast_away_nil($node);

  switch (node_get_group($node)) {
    case NodeGroup::SYNTAX:
    case NodeGroup::TOKEN:
      return false;
    case NodeGroup::TRIVIUM:
      return true;
  }
}

/**
 * The children are returned in source order.
 *
 * For the purposes of this function, NIL and MISSING are treated as a list of
 * length 0. In places where you'd expect to find a zero length list in the AST,
 * for example the parameter list of a function without parameters, you'll find
 * a missing instead. This function "does what you wanted" for "missing" lists.
 *
 * @throws For all other non-list kinds or if the list contains non-list-items.
 */
function list_get_items_of_children(
  Script $script,
  NillableSyntax $node,
)[]: vec<Node> {
  if ($node === NIL) {
    return vec[];
  }

  $node = _Private\cast_away_nil($node);

  switch (node_get_elaborated_group($node)) {
    case NodeElaboratedGroup::LIST:
      break;
    case NodeElaboratedGroup::MISSING:
      return vec[];
    default:
      throw new _Private\PhaException(Str\format(
        '%s expected a list or a missing, got a %s',
        __FUNCTION__,
        node_get_kind($script, $node),
      ));
  }

  return Vec\map(
    node_get_children($script, $node),
    $list_item ==> {
      $kind = node_get_kind($script, $list_item);
      _Private\enforce(
        $kind === KIND_LIST_ITEM,
        '%s expected a list with list_items, but found a %s in the list.',
        __FUNCTION__,
        $kind,
      );

      return node_get_first_childx($script, $list_item);
    },
  );
}

/**
 * Ancestors are returned in opposite source order.
 * So the first node is the parent, the second is the grand parent, etc.
 *
 * Special case: SCRIPT_NODE is its own parent, but this function has to have a
 * termination condition. For this reason, the ancestor chain is terminated at
 * the first instance of SCRIPT_NODE.
 */
function node_get_ancestors(Script $script, NillableNode $node)[]: vec<Node> {
  if ($node === NIL) {
    return vec[];
  }

  $node = _Private\cast_away_nil($node);
  $out = vec[];

  do {
    $node = node_get_parent($script, $node);
    $out[] = $node;
  } while ($node !== SCRIPT_NODE);

  return $out;
}

/**
 * Children are returned in source code order.
 */
function node_get_children(Script $script, NillableNode $node)[]: vec<Node> {
  if ($node === NIL) {
    return vec[];
  }

  $node = _Private\cast_away_nil($node);
  $tu = _Private\translation_unit_reveal($script);

  switch (node_get_elaborated_group($node)) {
    case NodeElaboratedGroup::SYNTAX:
      $node = _Private\syntax_from_node($node);
      return $tu->sliceSiblings(
        _Private\syntax_get_first_child_sibling_id($node),
        C\count(syntax_get_members($script, $node)),
      );

    case NodeElaboratedGroup::TOKEN:
      $parent_id = node_get_id($node);
      $child_id = $parent_id;
      $children = vec[];

      for (; ; ) {
        $child_id = _Private\node_id_add($child_id, 1);
        $child = $tu->getNodeById($child_id);
        if ($child === NIL) {
          return $children;
        }

        $child = _Private\cast_away_nil($child);

        if (_Private\node_get_parent_id($child) !== $parent_id) {
          return $children;
        }

        $children[] = $child;
      }

    case NodeElaboratedGroup::LIST:
      $node = _Private\syntax_from_node($node);
      return $tu->sliceSiblings(
        _Private\syntax_get_first_child_sibling_id($node),
        $tu->listGetSize($node),
      );

    case NodeElaboratedGroup::TRIVIUM:
    case NodeElaboratedGroup::MISSING:
      return vec[];
  }
}

function node_get_code(Script $script, NillableNode $node)[]: string {
  if ($node === NIL) {
    return '';
  }

  return node_get_source_range($script, _Private\cast_away_nil($node))
    |> _Private\translation_unit_reveal($script)->cutSourceRange($$);
}

/**
 * Returns the code with all the tokens glued together, (no comments / whitespace).
 *
 * The text returned is not code that can be reparsed.
 * This canonicalizes code by stripping comments and whitespace, but in doing so
 * it removes spaces that were needed for the program to parse:
 * ```
 * return 3; // >> return3;
 * ```
 */
function node_get_code_compressed(
  Script $script,
  NillableNode $node,
)[]: string {
  if ($node === NIL) {
    return '';
  }

  $node = _Private\cast_away_nil($node);

  switch (node_get_group($node)) {
    case NodeGroup::SYNTAX:
      return node_get_descendants($script, $node)
        |> Vec\filter($$, is_token<>)
        |> Vec\map($$, $t ==> token_get_text($script, as_token($t)))
        |> Str\join($$, '');
    case NodeGroup::TOKEN:
      return token_get_text($script, as_token($node));
    case NodeGroup::TRIVIUM:
      $token = trivium_get_parent($script, as_trivium($node));
      return token_get_text_trivium($script, $token) === $node
        ? node_get_code($script, $node)
        : '';
  }
}

/**
 * Descendants are returned in source order.
 */
function node_get_descendants(Script $script, NillableNode $node)[]: vec<Node> {
  if ($node === NIL) {
    return vec[];
  }

  $node = _Private\cast_away_nil($node);
  $last_descendant = node_get_last_descendant($script, $node);

  if ($last_descendant === NIL) {
    return vec[];
  }

  $last_descendant = _Private\cast_away_nil($last_descendant);
  $start = node_get_first_childx($script, $node) |> node_get_id($$);
  $to_exclusive = node_get_id($last_descendant);

  $tu = _Private\translation_unit_reveal($script);
  return $tu->cutSourceOrder($start, $to_exclusive);
}

function node_get_elaborated_group(Node $node)[]: NodeElaboratedGroup {
  switch (_Private\node_get_field_0($node)) {
    case 0:
      return NodeElaboratedGroup::TRIVIUM;
    case 1:
      return NodeElaboratedGroup::TOKEN;
    case -2:
      return NodeElaboratedGroup::SYNTAX;
    default:
      return _Private\node_get_field_1($node) === 0
        ? NodeElaboratedGroup::MISSING
        : NodeElaboratedGroup::LIST;
  }
}

function node_get_first_child(
  Script $script,
  NillableNode $node,
)[]: NillableNode {
  if ($node === NIL) {
    return NIL;
  }

  $node = _Private\cast_away_nil($node);
  $tu = _Private\translation_unit_reveal($script);

  switch (node_get_elaborated_group($node)) {
    case NodeElaboratedGroup::SYNTAX:
    case NodeElaboratedGroup::TOKEN:
    case NodeElaboratedGroup::LIST:
      return node_get_id($node)
        |> _Private\node_id_add($$, 1)
        |> $tu->getNodeByIdx($$);

    case NodeElaboratedGroup::TRIVIUM:
    case NodeElaboratedGroup::MISSING:
      return NIL;
  }
}

/**
 * @throws Iff $node has no children.
 */
function node_get_first_childx(Script $script, Node $node)[]: Node {
  $first_child = node_get_first_child($script, $node);

  if ($first_child !== NIL) {
    return _Private\cast_away_nil($first_child);
  }

  throw new _Private\PhaException(Str\format(
    '%s expected at least one child, got %s with 0 children.',
    __FUNCTION__,
    node_get_kind($script, $node),
  ));
}

function node_get_group(Node $node)[]: NodeGroup {
  switch (_Private\node_get_field_0($node)) {
    case 0:
      return NodeGroup::TRIVIUM;
    case 1:
      return NodeGroup::TOKEN;
    default:
      return NodeGroup::SYNTAX;
  }
}

function node_get_group_name(NillableNode $node)[]: string {
  if ($node === NIL) {
    return 'NIL';
  }

  switch (node_get_group(_Private\cast_away_nil($node))) {
    case NodeGroup::SYNTAX:
      return 'Syntax';
    case NodeGroup::TOKEN:
      return 'Token';
    case NodeGroup::TRIVIUM:
      return 'Trivium';
  }
}

function node_get_id(Node $node)[]: NodeId {
  return _Private\node_get_id($node);
}

function node_get_kind(Script $script, Node $node)[]: Kind {
  $tu = _Private\translation_unit_reveal($script);

  switch (node_get_elaborated_group($node)) {
    case NodeElaboratedGroup::SYNTAX:
      $kinds = $tu->getParseContext()->getSyntaxKinds();
      return _Private\node_get_interned_kind<SyntaxKind>($node)
        |> $kinds->fromInterned($$);

    case NodeElaboratedGroup::TOKEN:
      $kinds = $tu->getParseContext()->getTokenKinds();
      return _Private\node_get_interned_kind<TokenKind>($node)
        |> $kinds->fromInterned($$);

    case NodeElaboratedGroup::TRIVIUM:
      $kinds = $tu->getParseContext()->getTriviumKinds();
      return _Private\node_get_interned_kind<TriviumKind>($node)
        |> $kinds->fromInterned($$);

    case NodeElaboratedGroup::LIST:
      return KIND_NODE_LIST;
    case NodeElaboratedGroup::MISSING:
      return KIND_MISSING;
  }
}

function node_get_last_child(
  Script $script,
  NillableNode $node,
)[]: NillableNode {
  if ($node === NIL) {
    return NIL;
  }

  $node = _Private\cast_away_nil($node);
  $tu = _Private\translation_unit_reveal($script);

  switch (node_get_elaborated_group($node)) {
    case NodeElaboratedGroup::SYNTAX:
      $node = _Private\syntax_from_node($node);
      return node_get_nth_child(
        $script,
        $node,
        C\count(syntax_get_members($script, $node)) - 1,
      );

    case NodeElaboratedGroup::TOKEN:
      $parent_id = node_get_id($node);
      $child_id = $parent_id;
      $last_child = NIL;

      for (; ; ) {
        $child_id = _Private\node_id_add($child_id, 1);
        $child = $tu->getNodeById($child_id);
        if ($child === NIL) {
          return $last_child;
        }

        $child = _Private\cast_away_nil($child);

        if (_Private\node_get_parent_id($child) !== $parent_id) {
          return $last_child;
        }

        $last_child = $child;
      }

    case NodeElaboratedGroup::LIST:
      $node = _Private\syntax_from_node($node);
      return node_get_nth_child($script, $node, $tu->listGetSize($node) - 1);

    case NodeElaboratedGroup::TRIVIUM:
    case NodeElaboratedGroup::MISSING:
      return NIL;
  }
}

/**
 * @throws Iff $node has no children.
 */
function node_get_last_childx(Script $script, Node $node)[]: Node {
  $last_child = node_get_last_child($script, $node);

  if ($last_child !== NIL) {
    return _Private\cast_away_nil($last_child);
  }

  throw new _Private\PhaException(
    Str\format(
      '%s expected at least one child, got %s without children.',
      __FUNCTION__,
      node_get_kind($script, $node),
    ),
  );
}

function node_get_last_descendant(
  Script $script,
  NillableNode $node,
)[]: NillableNode {
  if ($node === NIL) {
    return NIL;
  }

  $node = _Private\cast_away_nil($node);

  switch (node_get_elaborated_group($node)) {
    case NodeElaboratedGroup::SYNTAX:
    case NodeElaboratedGroup::LIST:
      return node_get_last_childx($script, $node)
        |> node_get_last_descendant_or_self($script, $$);

    case NodeElaboratedGroup::TOKEN:
      return node_get_last_child($script, $node);

    case NodeElaboratedGroup::TRIVIUM:
    case NodeElaboratedGroup::MISSING:
      return NIL;
  }
}

function node_get_last_descendant_or_self(Script $script, Node $node)[]: Node {
  for (; ; ) {
    switch (node_get_elaborated_group($node)) {
      case NodeElaboratedGroup::SYNTAX:
      case NodeElaboratedGroup::LIST:
        $node = node_get_last_childx($script, $node);
        break;

      case NodeElaboratedGroup::TOKEN:
        return node_get_last_childx($script, $node);

      case NodeElaboratedGroup::TRIVIUM:
      case NodeElaboratedGroup::MISSING:
        return $node;
    }
  }
}

function node_get_line_and_column_numbers(
  Script $script,
  Node $node,
)[]: LineAndColumnNumbers {
  return node_get_source_range($script, $node)
    |> source_range_to_file_and_line_numbers($script, $$);
}

/**
 * @throws Iff $n < 0.
 */
function node_get_nth_child(
  Script $script,
  NillableNode $node,
  int $n,
)[]: NillableNode {
  if ($n === 0) {
    return node_get_first_child($script, $node);
  }

  _Private\enforce(
    $n > 0,
    '%s expected a valid offset (0 or greater), got %d.',
    __FUNCTION__,
    $n,
  );

  if ($node === NIL) {
    return NIL;
  }

  $node = _Private\cast_away_nil($node);

  $tu = _Private\translation_unit_reveal($script);

  switch (node_get_elaborated_group($node)) {
    case NodeElaboratedGroup::SYNTAX:
    case NodeElaboratedGroup::LIST:
      $child_node = _Private\syntax_from_node($node)
        |> _Private\syntax_get_first_child_sibling_id($$)
        |> _Private\sibling_id_add($$, $n)
        |> $tu->getNodeBySiblingId($$);

      if ($child_node === NIL) {
        return NIL;
      }

      $child_node = _Private\cast_away_nil($child_node);
      return _Private\node_get_parent_id($child_node) === node_get_id($node)
        ? $child_node
        : NIL;

    case NodeElaboratedGroup::TOKEN:
      $child_node = node_get_id($node)
        |> _Private\node_id_add($$, 1 + $n)
        |> $tu->getNodeById($$);

      if ($child_node === NIL) {
        return NIL;
      }

      $child_node = _Private\cast_away_nil($child_node);
      return _Private\node_get_parent_id($child_node) === node_get_id($node)
        ? $child_node
        : NIL;

    case NodeElaboratedGroup::TRIVIUM:
    case NodeElaboratedGroup::MISSING:
      return NIL;
  }
}

/**
 * @throws Iff $n < 0 or $node has no $nth child.
 */
function node_get_nth_childx(Script $script, Node $node, int $n)[]: Node {
  $nth_child = node_get_nth_child($script, $node, $n);

  if ($nth_child !== NIL) {
    return _Private\cast_away_nil($nth_child);
  }

  throw new _Private\PhaException(Str\format(
    '%s expected at least %d children, the given %s has no %s child.',
    __FUNCTION__,
    $n,
    node_get_kind($script, $node),
    _Private\grammatical_nth($n),
  ));
}

/**
 * Huh, shouldn't this return a NillableNode?
 * No, every Node is defined to have a parent.
 * The `SCRIPT_NODE` is defined to have a parent of `SCRIPT_NODE`.
 */
function node_get_parent(Script $script, Node $node)[]: Node {
  $tu = _Private\translation_unit_reveal($script);
  return _Private\node_get_parent_id($node)
    |> $tu->getNodeByIdx($$);
}

/**
 * This number can be used to sort nodes back into the order they came.
 */
function node_get_source_order(Node $node)[]: int {
  return node_get_id($node) |> _Private\node_id_to_int($$);
}

function node_get_source_range(Script $script, Node $node)[]: SourceRange {
  $node = _Private\cast_away_nil($node);

  $start = is_trivium($node)
    ? _Private\trivium_from_node($node)
    : _Private\node_get_next_trivium($script, $node);
  $end = node_get_last_descendant_or_self($script, $node)
    |> _Private\node_get_next_trivium($script, $$);

  if ($start === NIL) {
    // I am unable to imagine a script that has nodes past its last Trivium.
    // My reasoning goes:
    //  1. Every Syntax (except for Missing) has at least one member.
    //  2. Each of these members is either a Syntax or a Token.
    //  3. If the last member is a Syntax, goto 1.
    //  4. You'll now either have a Token or a missing.
    //  5. If you have a Token, it will always have a token-text-trivium.
    //  6. If you have a Missing, and there is no end-of-file token after you,
    //     what kind of mangled input have you given to the parser?
    throw new _Private\PhaException(
      'You have reached code I assumed to be unreachable.',
    );
  }

  $start_offset = _Private\cast_away_nil($start)
    |> _Private\trivium_get_source_byte_offset($$);
  $end_exclusive = $end === NIL
    ? null
    : _Private\trivium_get_source_byte_offset(_Private\cast_away_nil($end));

  return tuple($start_offset, $end_exclusive) |> _Private\source_range_hide($$);
}

/**
 * The ancestors are returned in opposite source order,
 * so parents precede grand parents, grand parents precede great grand parents.
 *
 * The returned ancestors contain only Syntaxes, any ancestors that are not
 * Syntaxes are skipped.
 *
 * @see `node_get_ancestors` for the special handling of SCRIPT_NODE.
 */
function node_get_syntax_ancestors(
  Script $script,
  NillableNode $node,
)[]: vec<Syntax> {
  if ($node === NIL) {
    return vec[];
  }

  $node = _Private\cast_away_nil($node);

  do {
    $node = node_get_parent($script, $node);
  } while (!is_syntax($node));

  $node = _Private\syntax_from_node($node);

  $out = vec[];
  $out[] = $node;

  while ($node !== SCRIPT_NODE) {
    $node = syntax_get_parent($script, $node);
    $out[] = $node;
  }

  return $out;
}

function script_get_syntaxes(Script $script)[]: vec<Syntax> {
  $tu = _Private\translation_unit_reveal($script);
  return $tu->getSourceOrder()
    |> Vec\filter($$, is_syntax<>)
    |> _Private\syntaxes_from_nodes($$);
}

function script_get_syntaxes_without_missing_and_list(
  Script $script,
)[]: vec<Syntax> {
  $tu = _Private\translation_unit_reveal($script);
  return $tu->getSourceOrder()
    |> Vec\filter(
      $$,
      $n ==> node_get_elaborated_group($n) === NodeElaboratedGroup::SYNTAX,
    )
    |> _Private\syntaxes_from_nodes($$);

}

function script_get_tokens(Script $script)[]: vec<Token> {
  $tu = _Private\translation_unit_reveal($script);
  return $tu->getSourceOrder()
    |> Vec\filter($$, is_token<>)
    |> _Private\tokens_from_nodes($$);
}

function script_get_trivia(Script $script)[]: vec<Trivium> {
  $tu = _Private\translation_unit_reveal($script);
  return $tu->getSourceOrder()
    |> Vec\filter($$, is_trivium<>)
    |> _Private\trivia_from_nodes($$);
}

function source_range_to_file_and_line_numbers(
  Script $script,
  SourceRange $range,
)[]: LineAndColumnNumbers {
  $breaks = _Private\translation_unit_reveal($script)->getLineBreaks();

  list($start, $end_exclusive) = _Private\source_range_reveal($range);
  $end_exclusive ??= C\lastx($breaks);

  $count = C\count($breaks);
  $i = $count - 1;

  while (_Private\source_byte_offset_is_less_than($start, $breaks[$i])) {
    // Quickly find a good place to start looking.
    $i = Math\maxva(0, $i - _Private\TranslationUnit::SOME_LARGE_JUMP);
  }

  while (
    $i < $count &&
    _Private\source_byte_offset_is_less_than_or_equal($breaks[$i], $start)
  ) {
    ++$i;
  }

  if ($i === 0) {
    $start_line = 1;
    $start_column = 0;
  } else {
    $start_line = $i;
    $start_column = _Private\source_byte_offset_to_int($start) -
      _Private\source_byte_offset_to_int($breaks[$i - 1]);
  }

  while (
    $i < $count &&
    _Private\source_byte_offset_is_less_than_or_equal(
      $breaks[$i],
      $end_exclusive,
    )
  ) {
    ++$i;
  }

  if ($i === 0) {
    $end_line = 1;
    $end_column = 0;
  } else {
    $end_line = $i;
    $end_column = _Private\source_byte_offset_to_int($end_exclusive) -
      _Private\source_byte_offset_to_int($breaks[$i - 1]);
  }

  return new LineAndColumnNumbers(
    $start_line - 1,
    $start_column,
    $end_line - 1,
    $end_column,
  );
}

/**
 * Member names are returned in source code order.
 */
function syntax_get_members(Script $script, Syntax $node)[]: vec<Member> {
  $tu = _Private\translation_unit_reveal($script);
  $structs = $tu->getParseContext()->getStructs();
  $kind = node_get_kind($script, $node) |> syntax_kind_from_kind($$);
  // This default is needed for List and Missing.
  // They don't get "learned" in the same way any other syntax would.
  return $structs->getRaw()[$kind] ?? vec[];
}

function syntax_get_parent(Script $script, Syntax $node)[]: Syntax {
  return node_get_parent($script, $node) |> _Private\syntax_from_node($$);
}

function syntax_member(Script $script, Syntax $node, Member $member)[]: Node {
  $ii = 0;

  foreach (syntax_get_members($script, $node) as $m) {
    if ($m === $member) {
      return node_get_nth_childx($script, $node, $ii);
    }

    ++$ii;
  }

  throw new _Private\PhaException(Str\format(
    'Expected a %s to get member %s, but got %s.',
    member_get_syntax_kind($member),
    member_get_name($member),
    node_get_kind($script, $node),
  ));
}

function token_get_parent(Script $script, Token $node)[]: Syntax {
  return node_get_parent($script, $node) |> _Private\syntax_from_node($$);
}

function token_get_text(Script $script, NillableToken $node)[]: string {
  if ($node === NIL) {
    return '';
  }

  return _Private\cast_away_nil($node)
    |> token_get_text_trivium($script, $$)
    |> node_get_code($script, $$);
}

function token_get_text_trivium(Script $script, Token $node)[]: Trivium {
  $tu = _Private\translation_unit_reveal($script);
  return _Private\node_get_field_3($node)
    |> _Private\node_id_from_int($$)
    |> $tu->getNodeByIdx($$)
    |> _Private\trivium_from_node($$);
}

function trivium_get_parent(Script $script, Trivium $node)[]: Token {
  return node_get_parent($script, $node) |> _Private\token_from_node($$);
}
}
///// src/parse.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
use namespace HH;

function parse(string $source, Context $ctx)[]: (Script, Context) {
  $ffp_parsed = HH\ffp_parse_string($source)
    |> _Private\change_array_kinds_for_hhvm_4_102($$ as AnyArray<_, _>);
  $parse_tree = $ffp_parsed['parse_tree'] as dict<_, _>;
  return parse_from_tree($parse_tree, $source, $ctx);
}
}
///// src/parse_from_tree.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
/**
 * @param $parse_tree ought to be the `$ffp_parsed['parse_tree']` of a script.
 * @see `\HH\ffp_parse_string()` and `\HH\ffp_parse_string_native()`.
 */
function parse_from_tree(
  dict<arraykey, mixed> $parse_tree,
  string $source_text,
  Context $ctx,
)[]: (Script, Context) {
  $ctx = _Private\context_reveal($ctx);
  $structs = $ctx->getStructs();
  $member_names = $structs->getRaw();
  $known_token_kinds = $ctx->getTokenKinds()->asKeyset();
  $known_trivium_kinds = $ctx->getTriviumKinds()->asKeyset();

  $intermediates = _Private\create_intermediates(
    $parse_tree,
    inout $member_names,
    inout $known_token_kinds,
    inout $known_trivium_kinds,
  );

  $ctx = $ctx->upgradeIfNeeded(
    $member_names,
    $known_token_kinds,
    $known_trivium_kinds,
  );

  $tu = _Private\create_translation_unit($intermediates, $source_text, $ctx);

  return
    tuple(_Private\translation_unit_hide($tu), _Private\context_hide($ctx));
}
}
///// src/public_types.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha{
type Context = _Private\Context;
type NillableNode = _Private\NillableNode;
type NillableSyntax = _Private\NillableSyntax;
type NillableToken = _Private\NillableToken;
type NillableTrivium = _Private\NillableTrivium;
type Node = _Private\Node;
type NodeId = _Private\NodeId;
type Resolver = _Private\Resolver;
type Script = _Private\Script;
type ReadyToSerializeContext = _Private\ReadyToSerializeContext;
type ReadyToSerializeScript = _Private\ReadyToSerializeScript;
type SourceRange = _Private\SourceRange;
type Syntax = _Private\Syntax;
type SyntaxIndex = _Private\KindIndex<Syntax, SyntaxKind>;
type Token = _Private\Token;
type TokenIndex = _Private\KindIndex<Token, TokenKind>;
type Trivium = _Private\Trivium;
type TriviumIndex = _Private\KindIndex<Trivium, TriviumKind>;

const _Private\Syntax SCRIPT_NODE = _Private\SCRIPT_NODE;
const _Private\Nil NIL = _Private\NIL;
}
///// src/_Private/PhaException.hack /////
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private{
use namespace HTL\Pha;
use type Exception;

final class PhaException extends Exception implements Pha\PhaException {
  <<__Override>>
  public function getMessage()[]: string {
    return $this->message;
  }
}
}
